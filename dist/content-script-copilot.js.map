{"version":3,"file":"content-script-copilot.js","mappings":"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","sources":["webpack://ecollm-chrome-extension/./node_modules/typescript-logging/dist/bundle/typescript-logging.esm.js","webpack://ecollm-chrome-extension/./node_modules/typescript-logging-log4ts-style/dist/bundle/typescript-logging-log4ts.esm.js","webpack://ecollm-chrome-extension/./node_modules/typescript-fsm/dist/stateMachine.js","webpack://ecollm-chrome-extension/webpack/bootstrap","webpack://ecollm-chrome-extension/./src/config/ConfigLog4j.ts","webpack://ecollm-chrome-extension/./src/content-scripts/common/EcoLLMStateMachine.ts","webpack://ecollm-chrome-extension/./src/content-scripts/content-script-copilot.ts"],"sourcesContent":["/**\n * Extends Map and adds a few convenient functions.\n */\nclass EnhancedMap extends Map {\n    /**\n     * If key has a mapping already returns the currently associated value. If\n     * there is no mapping, calls the computer which must return a value V.\n     * The value is then stored for given key and returned.\n     * @param key Key\n     * @param computer Computer which is called only if key has no mapping yet.\n     * @return Existing value if the key already existed, or the newly computed value.\n     */\n    computeIfAbsent(key, computer) {\n        if (this.has(key)) {\n            return this.get(key);\n        }\n        const newValue = computer(key);\n        this.set(key, newValue);\n        return newValue;\n    }\n    /**\n     * If the key exists already calls given computer, if the key does not exist\n     * this method does nothing.\n     *\n     * The computer is called with current key and current value associated. The\n     * computer can return a (new) value V or undefined. When undefined is returned\n     * the key is removed from this map, when a V is returned the key is updated\n     * with the new value V.\n     * @param key Key\n     * @param computer Computer which is called only if the key has a mapping already\n     * @return Undefined if the key has no mapping, otherwise the value returned from computer\n     */\n    computeIfPresent(key, computer) {\n        const currentValue = this.get(key);\n        if (currentValue === undefined) {\n            return undefined;\n        }\n        const newValue = computer(key, currentValue);\n        if (newValue !== undefined) {\n            this.set(key, newValue);\n        }\n        else {\n            this.delete(key);\n        }\n        return newValue;\n    }\n    /**\n     * Computes a value for given key, the computer can return a value V (in which case the map\n     * will set the value for given key), if it returns undefined the mapping for key K will be\n     * removed.\n     * @param key Key to compute\n     * @param computer Computer which is called, note that the currentValue argument contains the existing\n     *                 value or is undefined when no mapping exists for the key.\n     * @return The newly computed value\n     */\n    compute(key, computer) {\n        const currentValue = this.get(key);\n        const newValue = computer(key, currentValue);\n        if (newValue) {\n            this.set(key, newValue);\n        }\n        else {\n            this.delete(key);\n        }\n        return newValue;\n    }\n}\n\n/**\n * Internal log level (note: do NOT use LogLevel, or we get circular loading issues!)\n */\nvar InternalLogLevel;\n(function (InternalLogLevel) {\n    InternalLogLevel[InternalLogLevel[\"Trace\"] = 0] = \"Trace\";\n    InternalLogLevel[InternalLogLevel[\"Debug\"] = 1] = \"Debug\";\n    InternalLogLevel[InternalLogLevel[\"Info\"] = 2] = \"Info\";\n    InternalLogLevel[InternalLogLevel[\"Warn\"] = 3] = \"Warn\";\n    InternalLogLevel[InternalLogLevel[\"Error\"] = 4] = \"Error\";\n})(InternalLogLevel || (InternalLogLevel = {}));\n/**\n * Internal logger, this is NOT for end users. Instead this is used to enable logging for typescript-logging itself in case of problems.\n *\n * @param name Name of logger\n */\nfunction getInternalLogger(name) {\n    return provider.getLogger(name);\n}\n/**\n * Can be used to change the *internal* logging of the library.\n * Has no effect on end user logging.\n *\n * As such should normally not be used by end users.\n */\nconst INTERNAL_LOGGING_SETTINGS = {\n    /**\n     * Changes the log level for the internal logging (for all new and existing loggers)\n     * @param level New log level\n     */\n    setInternalLogLevel: (level) => provider.changeLogLevel(level),\n    /**\n     * Changes where messages are written to for all new and existing loggers),\n     * by default they are written to the console.\n     * @param fnOutput Function to write messages to\n     */\n    setOutput: (fnOutput) => provider.changeOutput(fnOutput),\n    /**\n     * Resets the log level and output back to defaults (level to error and writing to console)\n     * for all new and existing loggers.\n     */\n    reset: () => provider.reset(),\n};\nclass InternalLoggerImpl {\n    constructor(name, level, fnOutput) {\n        this._name = name;\n        this._level = level;\n        this._fnOutput = fnOutput;\n    }\n    trace(msg) {\n        this.log(InternalLogLevel.Trace, msg);\n    }\n    debug(msg) {\n        this.log(InternalLogLevel.Debug, msg);\n    }\n    error(msg, error) {\n        this.log(InternalLogLevel.Error, msg, error);\n    }\n    info(msg) {\n        this.log(InternalLogLevel.Info, msg);\n    }\n    warn(msg, error) {\n        this.log(InternalLogLevel.Warn, msg, error);\n    }\n    setLevel(level) {\n        this._level = level;\n    }\n    setOutput(fnOutput) {\n        this._fnOutput = fnOutput;\n    }\n    log(level, msg, error) {\n        if (this._level > level) {\n            return;\n        }\n        // tslint:disable-next-line:no-console\n        this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${msg()}${error ? \"\\n\" + error.stack : \"\"}`);\n    }\n}\nclass InternalProviderImpl {\n    constructor() {\n        this._loggers = new EnhancedMap();\n        this._logLevel = InternalLogLevel.Error;\n        this._fnOutput = InternalProviderImpl.logConsole;\n    }\n    getLogger(name) {\n        return this._loggers.computeIfAbsent(name, key => new InternalLoggerImpl(key, this._logLevel, this._fnOutput));\n    }\n    changeLogLevel(level) {\n        this._logLevel = level;\n        this._loggers.forEach(logger => logger.setLevel(level));\n    }\n    changeOutput(_fnOutput) {\n        this._fnOutput = _fnOutput;\n        this._loggers.forEach(logger => logger.setOutput(this._fnOutput));\n    }\n    reset() {\n        this.changeLogLevel(InternalLogLevel.Error);\n        this._fnOutput = InternalProviderImpl.logConsole;\n        this._loggers.forEach(logger => logger.setOutput(this._fnOutput));\n    }\n    static logConsole(msg) {\n        // tslint:disable-next-line:no-console\n        if (console && console.log) {\n            // tslint:disable-next-line:no-console\n            console.log(msg);\n        }\n    }\n}\nconst provider = new InternalProviderImpl();\n\nvar InternalLogger = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS,\n  get InternalLogLevel () { return InternalLogLevel; },\n  getInternalLogger: getInternalLogger\n});\n\n/**\n * Log level for a logger.\n */\nvar LogLevel;\n(function (LogLevel) {\n    // Do not change values/order. Logging a message relies on this.\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 3] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n    LogLevel[LogLevel[\"Fatal\"] = 5] = \"Fatal\";\n    LogLevel[LogLevel[\"Off\"] = 6] = \"Off\";\n})(LogLevel || (LogLevel = {}));\n/* tslint:disable:no-namespace */\n(function (LogLevel) {\n    /**\n     * Convert given value to LogLevel, if not matching returns undefined.\n     * @param val Value to convert\n     */\n    function toLogLevel(val) {\n        switch (val.toLowerCase()) {\n            case \"trace\":\n                return LogLevel.Trace;\n            case \"debug\":\n                return LogLevel.Debug;\n            case \"info\":\n                return LogLevel.Info;\n            case \"warn\":\n                return LogLevel.Warn;\n            case \"error\":\n                return LogLevel.Error;\n            case \"fatal\":\n                return LogLevel.Fatal;\n            case \"off\":\n                return LogLevel.Off;\n            default:\n                return undefined;\n        }\n    }\n    LogLevel.toLogLevel = toLogLevel;\n})(LogLevel || (LogLevel = {}));\n/* tslint:disable:enable-namespace */\n\n/**\n * Standard logger implementation that provides the basis for all loggers.\n */\nclass CoreLoggerImpl {\n    constructor(runtime) {\n        this._runtime = runtime;\n    }\n    get id() {\n        return this._runtime.id;\n    }\n    get logLevel() {\n        return this._runtime.level;\n    }\n    get runtimeSettings() {\n        /* Return it as new literal, we don't want people to play with our internal state */\n        return Object.assign({}, this._runtime);\n    }\n    set runtimeSettings(runtime) {\n        this._runtime = runtime;\n    }\n    trace(message, ...args) {\n        this.logMessage(LogLevel.Trace, message, args);\n    }\n    debug(message, ...args) {\n        this.logMessage(LogLevel.Debug, message, args);\n    }\n    info(message, ...args) {\n        this.logMessage(LogLevel.Info, message, args);\n    }\n    warn(message, ...args) {\n        this.logMessage(LogLevel.Warn, message, args);\n    }\n    error(message, ...args) {\n        this.logMessage(LogLevel.Error, message, args);\n    }\n    fatal(message, ...args) {\n        this.logMessage(LogLevel.Fatal, message, args);\n    }\n    logMessage(level, logMessageType, args) {\n        if (this._runtime.level > level) {\n            return;\n        }\n        const nowMillis = Date.now();\n        const message = typeof logMessageType === \"string\" ? logMessageType : logMessageType();\n        const errorAndArgs = CoreLoggerImpl.getErrorAndArgs(args);\n        /*\n         * Deal with raw message here.\n         */\n        switch (this._runtime.channel.type) {\n            case \"RawLogChannel\":\n                this._runtime.channel.write({\n                    message,\n                    exception: errorAndArgs.error,\n                    args: errorAndArgs.args,\n                    timeInMillis: nowMillis,\n                    level,\n                    logNames: this._runtime.name,\n                }, this._runtime.argumentFormatter);\n                return;\n            case \"LogChannel\":\n                this._runtime.channel.write(this.createLogMessage(message, level, errorAndArgs, nowMillis));\n                break;\n        }\n    }\n    formatArgValue(value) {\n        try {\n            return this._runtime.argumentFormatter(value);\n        }\n        catch (e) {\n            // We don't really care what failed, except that the convert function failed.\n            return `>>ARG CONVERT FAILED: '${value !== undefined ? value.toString() : \"undefined\"}'<<`;\n        }\n    }\n    createLogMessage(message, level, errorAndArgs, nowMillis) {\n        let errorResult;\n        const error = errorAndArgs.error;\n        const args = errorAndArgs.args;\n        if (error) {\n            errorResult = `${error.name}: ${error.message}`;\n            if (error.stack) {\n                errorResult += `@\\n${error.stack}`;\n            }\n        }\n        /*\n         * We need to add the date, and log names (in front of the now formatted message).\n         * Finally we also need to format any additional arguments and append after the message.\n         */\n        const dateFormatted = this._runtime.dateFormatter(nowMillis);\n        let levelAsStr = LogLevel[level].toUpperCase();\n        if (levelAsStr.length < 5) {\n            levelAsStr += \" \";\n        }\n        const names = typeof this._runtime.name === \"string\" ? this._runtime.name : this._runtime.name.join(\", \");\n        const argsFormatted = typeof args !== \"undefined\" && args.length > 0 ? (\" [\" + (args.map(arg => this.formatArgValue(arg))).join(\", \") + \"]\") : \"\";\n        const completedMessage = dateFormatted + \" \" + levelAsStr + \" [\" + names + \"] \" + message + argsFormatted;\n        return {\n            message: completedMessage,\n            error: errorResult,\n        };\n    }\n    static getErrorAndArgs(args) {\n        /*\n          The args are optional, but the first entry may be an Error or a function to an Error, or finally be a function to extra arguments.\n          The last is only true, if the length of args === 1, otherwise we expect args starting at pos 1 and further to be just that - args.\n         */\n        if (args.length === 0) {\n            return {};\n        }\n        let error;\n        let actualArgs;\n        const value0 = args[0];\n        /* If the first argument is an Error, we can stop straight away, the rest are additional arguments then if any */\n        if (value0 instanceof Error) {\n            error = value0;\n            actualArgs = args.length > 1 ? args.slice(1) : undefined;\n            return { error, args: actualArgs };\n        }\n        /* If the first argument is a function, it means either it will return the Error, or if the array length === 1 a function, returning the arguments */\n        if (typeof value0 === \"function\") {\n            const errorOrArgs = value0();\n            if (errorOrArgs instanceof Error) {\n                error = errorOrArgs;\n                actualArgs = args.length > 1 ? args.slice(1) : undefined;\n                return { error, args: actualArgs };\n            }\n            if (args.length === 1) {\n                /* The first argument was a function, we assume it returned the extra argument(s) */\n                if (Array.isArray(errorOrArgs)) {\n                    return { args: errorOrArgs.length > 0 ? errorOrArgs : undefined };\n                }\n                else {\n                    /* No idea what was returned we just assume a single value */\n                    return { args: errorOrArgs };\n                }\n            }\n            else {\n                /*\n                  This is a weird situation but there's no way to avoid it, the first argument was a function but did not return an Error and the args are > 1,\n                  so just add the args returned, as well as any remaining.\n                */\n                if (Array.isArray(errorOrArgs)) {\n                    return { args: [...errorOrArgs, ...args.slice(1)] };\n                }\n                return { args: [errorOrArgs, ...args.slice(1)] };\n            }\n        }\n        /* All args are ordinary arguments, or at least the first arg was not an Error or a Function, so we add all as args */\n        return { args };\n    }\n}\n\n/**\n * Pad given value with given fillChar from the beginning (default is an empty space)\n * @param value Value to pad\n * @param length The length the string must be\n * @param fillChar The padding char (1 char length allowed only)\n * @return Padded string or the same string if it is already of given length (or larger).\n */\nfunction padStart(value, length, fillChar = \" \") {\n    return padInternal(value, length, \"start\", fillChar);\n}\n/**\n * Pad given value with given fillChar from the end (default is an empty space)\n * @param value Value to pad\n * @param length The length the string must be\n * @param fillChar The padding char (1 char length allowed only)\n * @return Padded string or the same string if it is already of given length (or larger).\n */\nfunction padEnd(value, length, fillChar = \" \") {\n    return padInternal(value, length, \"end\", fillChar);\n}\n/**\n * Returns the max length of a string value in given array\n * @param arr Array to check\n * @return Max length, 0 if array is empty\n */\nfunction maxLengthStringValueInArray(arr) {\n    return arr\n        .map(v => v.length)\n        .reduce((previous, current) => {\n        if (current > previous) {\n            return current;\n        }\n        return previous;\n    }, 0);\n}\nfunction padInternal(value, length, padType, fillChar = \" \") {\n    if (length <= value.length) {\n        return value;\n    }\n    if (fillChar.length > 1) {\n        throw new Error(`Fill char must be one char exactly, it is: ${fillChar.length}`);\n    }\n    const charsNeeded = length - value.length;\n    let padding = \"\";\n    for (let i = 0; i < charsNeeded; i++) {\n        padding += fillChar;\n    }\n    if (padType === \"start\") {\n        return padding + value;\n    }\n    return value + padding;\n}\n\n/**\n * Default argument formatter function, used by the library, see {@link ArgumentFormatterType}.\n * Can be used by an end user as well if needed.\n * @param arg The argument to format\n * @returns argument stringified to string (JSON.stringify), if arg is undefined returns \"undefined\" (without quotes).\n */\nfunction formatArgument(arg) {\n    if (arg === undefined) {\n        return \"undefined\";\n    }\n    return JSON.stringify(arg);\n}\n/**\n * Default date formatter function, used by the library, see {@link DateFormatterType}.\n * Can be used by an end user as well if needed.\n * @param millisSinceEpoch Milliseconds since epoch\n * @returns The date in format: yyyy-MM-dd HH:mm:ss,SSS (example: 2021-02-26 09:06:28,123)\n */\nfunction formatDate(millisSinceEpoch) {\n    const date = new Date(millisSinceEpoch);\n    const year = date.getFullYear();\n    const month = padStart((date.getMonth() + 1).toString(), 2, \"0\");\n    const day = padStart(date.getDate().toString(), 2, \"0\");\n    const hours = padStart(date.getHours().toString(), 2, \"0\");\n    const minutes = padStart(date.getMinutes().toString(), 2, \"0\");\n    const seconds = padStart(date.getSeconds().toString(), 2, \"0\");\n    const millis = padStart(date.getMilliseconds().toString(), 3, \"0\");\n    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds},${millis}`;\n}\n\n/* tslint:disable:no-console */\n/**\n * Default standard LogChannel which logs to console.\n */\nclass ConsoleLogChannel {\n    constructor() {\n        this.type = \"LogChannel\";\n    }\n    write(msg) {\n        if (console && console.log) {\n            console.log(msg.message + (msg.error ? `\\n${msg.error}` : \"\"));\n        }\n    }\n}\n\n/* tslint:disable:no-namespace */\n/**\n * Provides access to various default channels provided by typescript logging.\n */\nvar DefaultChannels;\n(function (DefaultChannels) {\n    /**\n     * Create a new standard LogChannel that logs to the console.\n     */\n    function createConsoleChannel() {\n        return new ConsoleLogChannel();\n    }\n    DefaultChannels.createConsoleChannel = createConsoleChannel;\n})(DefaultChannels || (DefaultChannels = {}));\n\n/**\n * Implementation for {@link LogProvider}\n */\nclass LogProviderImpl {\n    constructor(name, settings) {\n        this._log = getInternalLogger(\"core.impl.LogProviderImpl\");\n        this._name = name;\n        this._settings = settings;\n        this._loggers = new EnhancedMap();\n        this._idToKeyMap = new EnhancedMap();\n        this._globalRuntimeSettings = { level: settings.level, channel: settings.channel };\n        this._nextLoggerId = 1;\n        this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);\n    }\n    get runtimeSettings() {\n        return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });\n    }\n    getLogger(name) {\n        return this.getOrCreateLogger(name);\n    }\n    updateLoggerRuntime(log, settings) {\n        this._log.debug(() => `Updating logger ${log.id} runtime settings using: '${JSON.stringify(settings)}'`);\n        const key = this._idToKeyMap.get(log.id);\n        if (key === undefined) {\n            this._log.warn(() => `Cannot update logger with id: ${log.id}, it was not found.`);\n            return false;\n        }\n        this._loggers.computeIfPresent(key, (currentKey, currentValue) => {\n            currentValue.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(currentValue.runtimeSettings, settings);\n            return currentValue;\n        });\n        return true;\n    }\n    updateRuntimeSettings(settings) {\n        this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(settings)}'`);\n        this._globalRuntimeSettings = {\n            /*\n             * Undefined check is necessary, as level is a number (and LogLevel.Trace = 0), a ternary check otherwise results in the annoying \"truthy/falsy\"\n             * behavior of javascript where 0 is seen as false.\n             */\n            level: settings.level !== undefined ? settings.level : this._globalRuntimeSettings.level,\n            channel: settings.channel !== undefined ? settings.channel : this._globalRuntimeSettings.channel,\n        };\n        this._loggers.forEach(logger => logger.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(logger.runtimeSettings, settings));\n    }\n    /**\n     * Removes all state and loggers, it reverts back to as it was after initial construction.\n     */\n    clear() {\n        this._loggers.clear();\n        this._idToKeyMap.clear();\n        this._globalRuntimeSettings = Object.assign({}, this._settings);\n        this._nextLoggerId = 1;\n    }\n    getOrCreateLogger(name) {\n        const key = LogProviderImpl.createKey(name);\n        const logger = this._loggers.computeIfAbsent(key, () => {\n            const runtime = {\n                level: this._globalRuntimeSettings.level,\n                channel: this._globalRuntimeSettings.channel,\n                id: this.nextLoggerId(),\n                name,\n                argumentFormatter: this._settings.argumentFormatter,\n                dateFormatter: this._settings.dateFormatter,\n            };\n            return new CoreLoggerImpl(runtime);\n        });\n        this._idToKeyMap.computeIfAbsent(logger.id, () => key);\n        return logger;\n    }\n    nextLoggerId() {\n        const result = this._name + \"_\" + this._nextLoggerId;\n        this._nextLoggerId++;\n        return result;\n    }\n    static mergeRuntimeSettingsIntoLogRuntime(currentSettings, settings) {\n        return Object.assign(Object.assign({}, currentSettings), { \n            /*\n             * Undefined check is necessary, as level is a number (and LogLevel.Trace = 0), a ternary check otherwise results in the annoying \"truthy/falsy\"\n             * behavior of javascript where 0 is seen as false.\n             */\n            level: settings.level !== undefined ? settings.level : currentSettings.level, channel: settings.channel !== undefined ? settings.channel : currentSettings.channel });\n    }\n    static createKey(name) {\n        if (typeof name === \"string\") {\n            return name;\n        }\n        return name.join(\",\");\n    }\n}\n\n/**\n * Create a new LogProvider, this is for flavor usage only. End users should not\n * use this and instead use whatever the flavor offers to build some config and\n * get loggers from there.\n */\nfunction createLogProvider(name, settings) {\n    return new LogProviderImpl(name, settings);\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  EnhancedMap: EnhancedMap,\n  maxLengthStringValueInArray: maxLengthStringValueInArray,\n  padEnd: padEnd,\n  padStart: padStart\n});\n\n/**\n * LogChannel that pushes log messages to a buffer.\n */\nclass ArrayLogChannel {\n    constructor() {\n        this._buffer = [];\n        this.type = \"LogChannel\";\n    }\n    write(msg) {\n        this._buffer.push(msg);\n    }\n    get logMessages() {\n        return this._buffer;\n    }\n    get messages() {\n        return this._buffer.map(msg => msg.message);\n    }\n}\n/**\n * RawLogChannel that pushes raw log messages to a buffer.\n */\nclass ArrayRawLogChannel {\n    constructor() {\n        this._buffer = [];\n        this.type = \"RawLogChannel\";\n    }\n    write(msg, _) {\n        this._buffer.push(msg);\n    }\n    get messages() {\n        return this._buffer.map(m => m.message);\n    }\n    get errors() {\n        return this._buffer.map(m => m.exception);\n    }\n    get size() {\n        return this._buffer.length;\n    }\n    get rawMessages() {\n        return this._buffer;\n    }\n    clear() {\n        this._buffer = [];\n    }\n}\n/**\n * Test class to help test the log control.\n */\nclass TestControlMessage {\n    constructor() {\n        this._messages = [];\n        this.write = this.write.bind(this);\n    }\n    get messages() {\n        return this._messages;\n    }\n    write(msg) {\n        this._messages.push(msg);\n    }\n    clear() {\n        this._messages = [];\n    }\n}\n\nvar TestClasses = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ArrayLogChannel: ArrayLogChannel,\n  ArrayRawLogChannel: ArrayRawLogChannel,\n  TestControlMessage: TestControlMessage\n});\n\nexport { InternalLogger as $internal, TestClasses as $test, DefaultChannels, LogLevel, createLogProvider, formatArgument, formatDate, index as util };\n//# sourceMappingURL=typescript-logging.esm.js.map\n","/**\n * Extends Map and adds a few convenient functions.\n */\nclass EnhancedMap extends Map {\n    /**\n     * If key has a mapping already returns the currently associated value. If\n     * there is no mapping, calls the computer which must return a value V.\n     * The value is then stored for given key and returned.\n     * @param key Key\n     * @param computer Computer which is called only if key has no mapping yet.\n     * @return Existing value if the key already existed, or the newly computed value.\n     */\n    computeIfAbsent(key, computer) {\n        if (this.has(key)) {\n            return this.get(key);\n        }\n        const newValue = computer(key);\n        this.set(key, newValue);\n        return newValue;\n    }\n    /**\n     * If the key exists already calls given computer, if the key does not exist\n     * this method does nothing.\n     *\n     * The computer is called with current key and current value associated. The\n     * computer can return a (new) value V or undefined. When undefined is returned\n     * the key is removed from this map, when a V is returned the key is updated\n     * with the new value V.\n     * @param key Key\n     * @param computer Computer which is called only if the key has a mapping already\n     * @return Undefined if the key has no mapping, otherwise the value returned from computer\n     */\n    computeIfPresent(key, computer) {\n        const currentValue = this.get(key);\n        if (currentValue === undefined) {\n            return undefined;\n        }\n        const newValue = computer(key, currentValue);\n        if (newValue !== undefined) {\n            this.set(key, newValue);\n        }\n        else {\n            this.delete(key);\n        }\n        return newValue;\n    }\n    /**\n     * Computes a value for given key, the computer can return a value V (in which case the map\n     * will set the value for given key), if it returns undefined the mapping for key K will be\n     * removed.\n     * @param key Key to compute\n     * @param computer Computer which is called, note that the currentValue argument contains the existing\n     *                 value or is undefined when no mapping exists for the key.\n     * @return The newly computed value\n     */\n    compute(key, computer) {\n        const currentValue = this.get(key);\n        const newValue = computer(key, currentValue);\n        if (newValue) {\n            this.set(key, newValue);\n        }\n        else {\n            this.delete(key);\n        }\n        return newValue;\n    }\n}\n\n/**\n * Internal log level (note: do NOT use LogLevel, or we get circular loading issues!)\n */\nvar InternalLogLevel;\n(function (InternalLogLevel) {\n    InternalLogLevel[InternalLogLevel[\"Trace\"] = 0] = \"Trace\";\n    InternalLogLevel[InternalLogLevel[\"Debug\"] = 1] = \"Debug\";\n    InternalLogLevel[InternalLogLevel[\"Info\"] = 2] = \"Info\";\n    InternalLogLevel[InternalLogLevel[\"Warn\"] = 3] = \"Warn\";\n    InternalLogLevel[InternalLogLevel[\"Error\"] = 4] = \"Error\";\n})(InternalLogLevel || (InternalLogLevel = {}));\n/**\n * Internal logger, this is NOT for end users. Instead this is used to enable logging for typescript-logging itself in case of problems.\n *\n * @param name Name of logger\n */\nfunction getInternalLogger(name) {\n    return provider.getLogger(name);\n}\n/**\n * Can be used to change the *internal* logging of the library.\n * Has no effect on end user logging.\n *\n * As such should normally not be used by end users.\n */\nconst INTERNAL_LOGGING_SETTINGS = {\n    /**\n     * Changes the log level for the internal logging (for all new and existing loggers)\n     * @param level New log level\n     */\n    setInternalLogLevel: (level) => provider.changeLogLevel(level),\n    /**\n     * Changes where messages are written to for all new and existing loggers),\n     * by default they are written to the console.\n     * @param fnOutput Function to write messages to\n     */\n    setOutput: (fnOutput) => provider.changeOutput(fnOutput),\n    /**\n     * Resets the log level and output back to defaults (level to error and writing to console)\n     * for all new and existing loggers.\n     */\n    reset: () => provider.reset(),\n};\nclass InternalLoggerImpl {\n    constructor(name, level, fnOutput) {\n        this._name = name;\n        this._level = level;\n        this._fnOutput = fnOutput;\n    }\n    trace(msg) {\n        this.log(InternalLogLevel.Trace, msg);\n    }\n    debug(msg) {\n        this.log(InternalLogLevel.Debug, msg);\n    }\n    error(msg, error) {\n        this.log(InternalLogLevel.Error, msg, error);\n    }\n    info(msg) {\n        this.log(InternalLogLevel.Info, msg);\n    }\n    warn(msg, error) {\n        this.log(InternalLogLevel.Warn, msg, error);\n    }\n    setLevel(level) {\n        this._level = level;\n    }\n    setOutput(fnOutput) {\n        this._fnOutput = fnOutput;\n    }\n    log(level, msg, error) {\n        if (this._level > level) {\n            return;\n        }\n        // tslint:disable-next-line:no-console\n        this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${msg()}${error ? \"\\n\" + error.stack : \"\"}`);\n    }\n}\nclass InternalProviderImpl {\n    constructor() {\n        this._loggers = new EnhancedMap();\n        this._logLevel = InternalLogLevel.Error;\n        this._fnOutput = InternalProviderImpl.logConsole;\n    }\n    getLogger(name) {\n        return this._loggers.computeIfAbsent(name, key => new InternalLoggerImpl(key, this._logLevel, this._fnOutput));\n    }\n    changeLogLevel(level) {\n        this._logLevel = level;\n        this._loggers.forEach(logger => logger.setLevel(level));\n    }\n    changeOutput(_fnOutput) {\n        this._fnOutput = _fnOutput;\n        this._loggers.forEach(logger => logger.setOutput(this._fnOutput));\n    }\n    reset() {\n        this.changeLogLevel(InternalLogLevel.Error);\n        this._fnOutput = InternalProviderImpl.logConsole;\n        this._loggers.forEach(logger => logger.setOutput(this._fnOutput));\n    }\n    static logConsole(msg) {\n        // tslint:disable-next-line:no-console\n        if (console && console.log) {\n            // tslint:disable-next-line:no-console\n            console.log(msg);\n        }\n    }\n}\nconst provider = new InternalProviderImpl();\n\nvar InternalLogger = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS,\n  get InternalLogLevel () { return InternalLogLevel; },\n  getInternalLogger: getInternalLogger\n});\n\n/**\n * Log level for a logger.\n */\nvar LogLevel;\n(function (LogLevel) {\n    // Do not change values/order. Logging a message relies on this.\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 3] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n    LogLevel[LogLevel[\"Fatal\"] = 5] = \"Fatal\";\n    LogLevel[LogLevel[\"Off\"] = 6] = \"Off\";\n})(LogLevel || (LogLevel = {}));\n/* tslint:disable:no-namespace */\n(function (LogLevel) {\n    /**\n     * Convert given value to LogLevel, if not matching returns undefined.\n     * @param val Value to convert\n     */\n    function toLogLevel(val) {\n        switch (val.toLowerCase()) {\n            case \"trace\":\n                return LogLevel.Trace;\n            case \"debug\":\n                return LogLevel.Debug;\n            case \"info\":\n                return LogLevel.Info;\n            case \"warn\":\n                return LogLevel.Warn;\n            case \"error\":\n                return LogLevel.Error;\n            case \"fatal\":\n                return LogLevel.Fatal;\n            case \"off\":\n                return LogLevel.Off;\n            default:\n                return undefined;\n        }\n    }\n    LogLevel.toLogLevel = toLogLevel;\n})(LogLevel || (LogLevel = {}));\n/* tslint:disable:enable-namespace */\n\n/**\n * Standard logger implementation that provides the basis for all loggers.\n */\nclass CoreLoggerImpl {\n    constructor(runtime) {\n        this._runtime = runtime;\n    }\n    get id() {\n        return this._runtime.id;\n    }\n    get logLevel() {\n        return this._runtime.level;\n    }\n    get runtimeSettings() {\n        /* Return it as new literal, we don't want people to play with our internal state */\n        return Object.assign({}, this._runtime);\n    }\n    set runtimeSettings(runtime) {\n        this._runtime = runtime;\n    }\n    trace(message, ...args) {\n        this.logMessage(LogLevel.Trace, message, args);\n    }\n    debug(message, ...args) {\n        this.logMessage(LogLevel.Debug, message, args);\n    }\n    info(message, ...args) {\n        this.logMessage(LogLevel.Info, message, args);\n    }\n    warn(message, ...args) {\n        this.logMessage(LogLevel.Warn, message, args);\n    }\n    error(message, ...args) {\n        this.logMessage(LogLevel.Error, message, args);\n    }\n    fatal(message, ...args) {\n        this.logMessage(LogLevel.Fatal, message, args);\n    }\n    logMessage(level, logMessageType, args) {\n        if (this._runtime.level > level) {\n            return;\n        }\n        const nowMillis = Date.now();\n        const message = typeof logMessageType === \"string\" ? logMessageType : logMessageType();\n        const errorAndArgs = CoreLoggerImpl.getErrorAndArgs(args);\n        /*\n         * Deal with raw message here.\n         */\n        switch (this._runtime.channel.type) {\n            case \"RawLogChannel\":\n                this._runtime.channel.write({\n                    message,\n                    exception: errorAndArgs.error,\n                    args: errorAndArgs.args,\n                    timeInMillis: nowMillis,\n                    level,\n                    logNames: this._runtime.name,\n                }, this._runtime.argumentFormatter);\n                return;\n            case \"LogChannel\":\n                this._runtime.channel.write(this.createLogMessage(message, level, errorAndArgs, nowMillis));\n                break;\n        }\n    }\n    formatArgValue(value) {\n        try {\n            return this._runtime.argumentFormatter(value);\n        }\n        catch (e) {\n            // We don't really care what failed, except that the convert function failed.\n            return `>>ARG CONVERT FAILED: '${value !== undefined ? value.toString() : \"undefined\"}'<<`;\n        }\n    }\n    createLogMessage(message, level, errorAndArgs, nowMillis) {\n        let errorResult;\n        const error = errorAndArgs.error;\n        const args = errorAndArgs.args;\n        if (error) {\n            errorResult = `${error.name}: ${error.message}`;\n            if (error.stack) {\n                errorResult += `@\\n${error.stack}`;\n            }\n        }\n        /*\n         * We need to add the date, and log names (in front of the now formatted message).\n         * Finally we also need to format any additional arguments and append after the message.\n         */\n        const dateFormatted = this._runtime.dateFormatter(nowMillis);\n        let levelAsStr = LogLevel[level].toUpperCase();\n        if (levelAsStr.length < 5) {\n            levelAsStr += \" \";\n        }\n        const names = typeof this._runtime.name === \"string\" ? this._runtime.name : this._runtime.name.join(\", \");\n        const argsFormatted = typeof args !== \"undefined\" && args.length > 0 ? (\" [\" + (args.map(arg => this.formatArgValue(arg))).join(\", \") + \"]\") : \"\";\n        const completedMessage = dateFormatted + \" \" + levelAsStr + \" [\" + names + \"] \" + message + argsFormatted;\n        return {\n            message: completedMessage,\n            error: errorResult,\n        };\n    }\n    static getErrorAndArgs(args) {\n        /*\n          The args are optional, but the first entry may be an Error or a function to an Error, or finally be a function to extra arguments.\n          The last is only true, if the length of args === 1, otherwise we expect args starting at pos 1 and further to be just that - args.\n         */\n        if (args.length === 0) {\n            return {};\n        }\n        let error;\n        let actualArgs;\n        const value0 = args[0];\n        /* If the first argument is an Error, we can stop straight away, the rest are additional arguments then if any */\n        if (value0 instanceof Error) {\n            error = value0;\n            actualArgs = args.length > 1 ? args.slice(1) : undefined;\n            return { error, args: actualArgs };\n        }\n        /* If the first argument is a function, it means either it will return the Error, or if the array length === 1 a function, returning the arguments */\n        if (typeof value0 === \"function\") {\n            const errorOrArgs = value0();\n            if (errorOrArgs instanceof Error) {\n                error = errorOrArgs;\n                actualArgs = args.length > 1 ? args.slice(1) : undefined;\n                return { error, args: actualArgs };\n            }\n            if (args.length === 1) {\n                /* The first argument was a function, we assume it returned the extra argument(s) */\n                if (Array.isArray(errorOrArgs)) {\n                    return { args: errorOrArgs.length > 0 ? errorOrArgs : undefined };\n                }\n                else {\n                    /* No idea what was returned we just assume a single value */\n                    return { args: errorOrArgs };\n                }\n            }\n            else {\n                /*\n                  This is a weird situation but there's no way to avoid it, the first argument was a function but did not return an Error and the args are > 1,\n                  so just add the args returned, as well as any remaining.\n                */\n                if (Array.isArray(errorOrArgs)) {\n                    return { args: [...errorOrArgs, ...args.slice(1)] };\n                }\n                return { args: [errorOrArgs, ...args.slice(1)] };\n            }\n        }\n        /* All args are ordinary arguments, or at least the first arg was not an Error or a Function, so we add all as args */\n        return { args };\n    }\n}\n\n/**\n * Pad given value with given fillChar from the beginning (default is an empty space)\n * @param value Value to pad\n * @param length The length the string must be\n * @param fillChar The padding char (1 char length allowed only)\n * @return Padded string or the same string if it is already of given length (or larger).\n */\nfunction padStart(value, length, fillChar = \" \") {\n    return padInternal(value, length, \"start\", fillChar);\n}\n/**\n * Pad given value with given fillChar from the end (default is an empty space)\n * @param value Value to pad\n * @param length The length the string must be\n * @param fillChar The padding char (1 char length allowed only)\n * @return Padded string or the same string if it is already of given length (or larger).\n */\nfunction padEnd(value, length, fillChar = \" \") {\n    return padInternal(value, length, \"end\", fillChar);\n}\n/**\n * Returns the max length of a string value in given array\n * @param arr Array to check\n * @return Max length, 0 if array is empty\n */\nfunction maxLengthStringValueInArray(arr) {\n    return arr\n        .map(v => v.length)\n        .reduce((previous, current) => {\n        if (current > previous) {\n            return current;\n        }\n        return previous;\n    }, 0);\n}\nfunction padInternal(value, length, padType, fillChar = \" \") {\n    if (length <= value.length) {\n        return value;\n    }\n    if (fillChar.length > 1) {\n        throw new Error(`Fill char must be one char exactly, it is: ${fillChar.length}`);\n    }\n    const charsNeeded = length - value.length;\n    let padding = \"\";\n    for (let i = 0; i < charsNeeded; i++) {\n        padding += fillChar;\n    }\n    if (padType === \"start\") {\n        return padding + value;\n    }\n    return value + padding;\n}\n\n/**\n * Default argument formatter function, used by the library, see {@link ArgumentFormatterType}.\n * Can be used by an end user as well if needed.\n * @param arg The argument to format\n * @returns argument stringified to string (JSON.stringify), if arg is undefined returns \"undefined\" (without quotes).\n */\nfunction formatArgument(arg) {\n    if (arg === undefined) {\n        return \"undefined\";\n    }\n    return JSON.stringify(arg);\n}\n/**\n * Default date formatter function, used by the library, see {@link DateFormatterType}.\n * Can be used by an end user as well if needed.\n * @param millisSinceEpoch Milliseconds since epoch\n * @returns The date in format: yyyy-MM-dd HH:mm:ss,SSS (example: 2021-02-26 09:06:28,123)\n */\nfunction formatDate(millisSinceEpoch) {\n    const date = new Date(millisSinceEpoch);\n    const year = date.getFullYear();\n    const month = padStart((date.getMonth() + 1).toString(), 2, \"0\");\n    const day = padStart(date.getDate().toString(), 2, \"0\");\n    const hours = padStart(date.getHours().toString(), 2, \"0\");\n    const minutes = padStart(date.getMinutes().toString(), 2, \"0\");\n    const seconds = padStart(date.getSeconds().toString(), 2, \"0\");\n    const millis = padStart(date.getMilliseconds().toString(), 3, \"0\");\n    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds},${millis}`;\n}\n\n/* tslint:disable:no-console */\n/**\n * Default standard LogChannel which logs to console.\n */\nclass ConsoleLogChannel {\n    constructor() {\n        this.type = \"LogChannel\";\n    }\n    write(msg) {\n        if (console && console.log) {\n            console.log(msg.message + (msg.error ? `\\n${msg.error}` : \"\"));\n        }\n    }\n}\n\n/* tslint:disable:no-namespace */\n/**\n * Provides access to various default channels provided by typescript logging.\n */\nvar DefaultChannels;\n(function (DefaultChannels) {\n    /**\n     * Create a new standard LogChannel that logs to the console.\n     */\n    function createConsoleChannel() {\n        return new ConsoleLogChannel();\n    }\n    DefaultChannels.createConsoleChannel = createConsoleChannel;\n})(DefaultChannels || (DefaultChannels = {}));\n\n/**\n * Implementation for {@link LogProvider}\n */\nclass LogProviderImpl {\n    constructor(name, settings) {\n        this._log = getInternalLogger(\"core.impl.LogProviderImpl\");\n        this._name = name;\n        this._settings = settings;\n        this._loggers = new EnhancedMap();\n        this._idToKeyMap = new EnhancedMap();\n        this._globalRuntimeSettings = { level: settings.level, channel: settings.channel };\n        this._nextLoggerId = 1;\n        this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);\n    }\n    get runtimeSettings() {\n        return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });\n    }\n    getLogger(name) {\n        return this.getOrCreateLogger(name);\n    }\n    updateLoggerRuntime(log, settings) {\n        this._log.debug(() => `Updating logger ${log.id} runtime settings using: '${JSON.stringify(settings)}'`);\n        const key = this._idToKeyMap.get(log.id);\n        if (key === undefined) {\n            this._log.warn(() => `Cannot update logger with id: ${log.id}, it was not found.`);\n            return false;\n        }\n        this._loggers.computeIfPresent(key, (currentKey, currentValue) => {\n            currentValue.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(currentValue.runtimeSettings, settings);\n            return currentValue;\n        });\n        return true;\n    }\n    updateRuntimeSettings(settings) {\n        this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(settings)}'`);\n        this._globalRuntimeSettings = {\n            /*\n             * Undefined check is necessary, as level is a number (and LogLevel.Trace = 0), a ternary check otherwise results in the annoying \"truthy/falsy\"\n             * behavior of javascript where 0 is seen as false.\n             */\n            level: settings.level !== undefined ? settings.level : this._globalRuntimeSettings.level,\n            channel: settings.channel !== undefined ? settings.channel : this._globalRuntimeSettings.channel,\n        };\n        this._loggers.forEach(logger => logger.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(logger.runtimeSettings, settings));\n    }\n    /**\n     * Removes all state and loggers, it reverts back to as it was after initial construction.\n     */\n    clear() {\n        this._loggers.clear();\n        this._idToKeyMap.clear();\n        this._globalRuntimeSettings = Object.assign({}, this._settings);\n        this._nextLoggerId = 1;\n    }\n    getOrCreateLogger(name) {\n        const key = LogProviderImpl.createKey(name);\n        const logger = this._loggers.computeIfAbsent(key, () => {\n            const runtime = {\n                level: this._globalRuntimeSettings.level,\n                channel: this._globalRuntimeSettings.channel,\n                id: this.nextLoggerId(),\n                name,\n                argumentFormatter: this._settings.argumentFormatter,\n                dateFormatter: this._settings.dateFormatter,\n            };\n            return new CoreLoggerImpl(runtime);\n        });\n        this._idToKeyMap.computeIfAbsent(logger.id, () => key);\n        return logger;\n    }\n    nextLoggerId() {\n        const result = this._name + \"_\" + this._nextLoggerId;\n        this._nextLoggerId++;\n        return result;\n    }\n    static mergeRuntimeSettingsIntoLogRuntime(currentSettings, settings) {\n        return Object.assign(Object.assign({}, currentSettings), { \n            /*\n             * Undefined check is necessary, as level is a number (and LogLevel.Trace = 0), a ternary check otherwise results in the annoying \"truthy/falsy\"\n             * behavior of javascript where 0 is seen as false.\n             */\n            level: settings.level !== undefined ? settings.level : currentSettings.level, channel: settings.channel !== undefined ? settings.channel : currentSettings.channel });\n    }\n    static createKey(name) {\n        if (typeof name === \"string\") {\n            return name;\n        }\n        return name.join(\",\");\n    }\n}\n\n/**\n * Create a new LogProvider, this is for flavor usage only. End users should not\n * use this and instead use whatever the flavor offers to build some config and\n * get loggers from there.\n */\nfunction createLogProvider(name, settings) {\n    return new LogProviderImpl(name, settings);\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  EnhancedMap: EnhancedMap,\n  maxLengthStringValueInArray: maxLengthStringValueInArray,\n  padEnd: padEnd,\n  padStart: padStart\n});\n\nfunction log4TSGroupConfigDebug(config) {\n    return `Log4TSGroupConfig=level: ${LogLevel[config.level].toString()}, expression: ${config.expression.toString()}, (omitted functions/channel)`;\n}\nfunction log4TSConfigDebug(config) {\n    const groupLog = config.groups.map(g => log4TSGroupConfigDebug(g)).join(\", \");\n    return `Log4TSGroupConfig=level: ${LogLevel[config.level].toString()}, groups: ${groupLog}, (omitted functions/channel)`;\n}\n\n/**\n * Implementation class for Log4TSProvider.\n */\nclass Log4TSProviderImpl {\n    constructor(name, defaultConfig, groupConfigs) {\n        this._log = InternalLogger.getInternalLogger(\"log4ts.impl.Log4TSProviderImpl\");\n        this._name = name;\n        /* The default config, used as fallback if a logger does not match any group */\n        this._defaultConfig = [Object.assign(Object.assign({}, defaultConfig), { identifier: defaultConfig.identifier }), createLogProvider(\"log4ts_\" + name + \"_\" + defaultConfig.identifier, defaultConfig)];\n        /* Create various providers for the different groups so each will have the correct config */\n        this._logProviders = new Map(groupConfigs.map(config => {\n            const updatedConfig = Object.assign({}, config);\n            const provider = createLogProvider(\"log4ts_\" + name + \"_\" + config.identifier, config);\n            return [config.identifier, { groupConfig: updatedConfig, provider }];\n        }));\n        this._log.trace(() => {\n            const groupProvLog = [...this._logProviders.values()].map(e => log4TSGroupConfigDebug(e.groupConfig)).join(\", \");\n            return `Creating Log4TSProviderImpl '${this._name}', defaultConfig: ${log4TSGroupConfigDebug(this._defaultConfig[0])}, groupConfigs: ${groupProvLog}`;\n        });\n    }\n    get name() {\n        return this._name;\n    }\n    get config() {\n        /* We create the settings to return anew, to prevent people change the content in any way */\n        return Object.assign({}, this._defaultConfig[0]);\n    }\n    get groupConfigs() {\n        /* We create the settings to return anew, to prevent people change the content in any way */\n        return [...this._logProviders.values()].map(v => (Object.assign({}, v.groupConfig)));\n    }\n    getLogger(name) {\n        /* Walk them in insertion order, that is the order we must match for */\n        for (const value of this._logProviders.values()) {\n            if (value.groupConfig.expression.test(name)) {\n                return value.provider.getLogger(name);\n            }\n        }\n        /* Fallback to the default we don't care if it matches in this case */\n        return this._defaultConfig[1].getLogger(name);\n    }\n    updateRuntimeSettingsGroup(identifier, config) {\n        const value = this._logProviders.get(identifier);\n        if (value === undefined) {\n            throw new Error(`Cannot update group with identifier '${identifier}', it does not exist.`);\n        }\n        this._log.debug(() => `Will update ${log4TSGroupConfigDebug(value.groupConfig)}, associated LogProvider '${value.provider}' - applying runtime change: ${JSON.stringify(config)}.`);\n        Log4TSProviderImpl.updateLog4TGroupConfig(value.groupConfig, value.provider, config);\n    }\n    updateRuntimeSettings(settings) {\n        this._log.debug(() => `Will update settings for all groups and existing loggers - will apply runtime change: ${JSON.stringify(settings)}.`);\n        this._logProviders.forEach(value => {\n            const groupConfig = value.groupConfig;\n            const provider = value.provider;\n            this._log.debug(() => `Will update ${log4TSGroupConfigDebug(groupConfig)}, associated LogProvider '${provider}' - applying runtime change: ${JSON.stringify(settings)}.`);\n            Log4TSProviderImpl.updateLog4TGroupConfig(groupConfig, provider, settings);\n        });\n    }\n    static updateLog4TGroupConfig(cfg, provider, runtimeSettings) {\n        if (runtimeSettings.level) {\n            cfg.level = runtimeSettings.level;\n        }\n        if (runtimeSettings.channel) {\n            cfg.channel = runtimeSettings.channel;\n        }\n        provider.updateRuntimeSettings(runtimeSettings);\n    }\n}\n\n/**\n * Implementation for Log4TSControlProvider.\n */\nclass Log4TSControlProviderImpl {\n    constructor(provider, messageChannel) {\n        this._provider = provider;\n        this._messageChannel = messageChannel;\n        // Identifier is guaranteed to be set internally.\n        this._originalLogLevels = Log4TSControlProviderImpl.loadCurrentGroupLogLevels(provider);\n    }\n    get name() {\n        return this._provider.name;\n    }\n    showSettings() {\n        let result = `Available group configs (Log4TSProvider '${this._provider.name}'):\\n`;\n        /*\n         * Make the identifier always set, similar on how to update a group.\n         */\n        const groupConfigs = this._provider.groupConfigs.map(cfg => ({\n            level: LogLevel[cfg.level],\n            channelDescription: cfg.channel.toString ? cfg.channel.toString() : JSON.stringify(cfg.channel),\n            identifier: cfg.identifier,\n        }));\n        const maxWidthIndex = groupConfigs.length.toString().length;\n        const maxWidthIdentifier = index.maxLengthStringValueInArray(groupConfigs.map(cfg => cfg.identifier));\n        const maxWidthLevel = 5;\n        /*\n          We create this kind of output:\n    \n          Available group configs (Log4TSProvider 'test'):\n            [0, /model.+/:             level=Error]\n            [1, /advanced.+/:          level=Warn ]\n            [2, my awesome identifier: level=Error]\n            [3, /blaat.blaat.+/:       level=Error]\n         */\n        const providerLines = groupConfigs\n            .map((cfg, index$1) => `  [${index.padStart(index$1.toString(), maxWidthIndex)}, ${index.padEnd(cfg.identifier, maxWidthIdentifier)} (level=${index.padEnd(cfg.level, maxWidthLevel)})]`)\n            .join(\"\\n\");\n        result += providerLines + \"\\n\";\n        this._messageChannel(result);\n    }\n    update(level, groupId) {\n        const newLevel = LogLevel.toLogLevel(level);\n        if (newLevel === undefined) {\n            throw new Error(`Cannot update log provider, log level '${level}' is invalid.`);\n        }\n        const settings = {\n            level: newLevel,\n        };\n        /*\n         * Update all groups.\n         */\n        if (groupId === undefined) {\n            this._provider.updateRuntimeSettings(settings);\n            this._messageChannel(\"Updated all group configs successfully.\");\n            return;\n        }\n        /*\n         * Find the group by index and update it using its identifier.\n         */\n        if (typeof groupId === \"number\") {\n            const groups = this._provider.groupConfigs;\n            if (groupId < 0 || groupId >= groups.length) {\n                throw new Error(`Group config with index '${groupId}' does not exist (outside of range).`);\n            }\n            const expectedGroup = groups[groupId];\n            this._provider.updateRuntimeSettingsGroup(expectedGroup.identifier, settings);\n            this._messageChannel(`Updated group config with index '${groupId}' successfully.`);\n            return;\n        }\n        /* Update the group by its identifier directly */\n        this._provider.updateRuntimeSettingsGroup(groupId, settings);\n        this._messageChannel(`Updated group config with id '${groupId}' successfully.`);\n    }\n    reset() {\n        this._originalLogLevels.forEach((value, key) => {\n            this._provider.updateRuntimeSettingsGroup(key, { level: value });\n        });\n        this._messageChannel(\"Successfully reset log levels back to original state (from when this Log4TSControlProvider was created).\");\n    }\n    save() {\n        if (!localStorage) {\n            this._messageChannel(\"Cannot save state, localStorage is not available.\");\n            return;\n        }\n        const data = {\n            name: this._provider.name,\n            groups: this._provider.groupConfigs.map(cfg => ({ identifier: cfg.identifier, level: LogLevel[cfg.level] })),\n        };\n        localStorage.setItem(this.createKey(), JSON.stringify(data));\n        this._messageChannel(`Successfully saved state for Log4TSControlProvider '${this._provider.name}'.`);\n    }\n    restore(logRestoreFailures) {\n        const finalLogRestoreFailures = logRestoreFailures !== undefined ? logRestoreFailures : true;\n        if (!localStorage) {\n            if (finalLogRestoreFailures) {\n                this._messageChannel(`Will not attempt to restore state for Log4TSControlProvider '${this._provider.name}', localStorage is not available.`);\n            }\n            return;\n        }\n        const key = this.createKey();\n        const value = localStorage.getItem(key);\n        if (value === null) {\n            if (finalLogRestoreFailures) {\n                this._messageChannel(`Cannot restore state for Log4TSControlProvider '${this._provider.name}', no data available.`);\n            }\n            return;\n        }\n        try {\n            const savedData = JSON.parse(value);\n            if (this._provider.name !== savedData.name) {\n                if (finalLogRestoreFailures) {\n                    this._messageChannel(`Cannot restore state for Log4TSControlProvider '${this._provider.name}', data is not for provider - found name '${savedData.name}'.`);\n                }\n                return;\n            }\n            this.restoreGroups(savedData, finalLogRestoreFailures);\n            this._originalLogLevels = Log4TSControlProviderImpl.loadCurrentGroupLogLevels(this._provider);\n        }\n        catch (e) {\n            localStorage.removeItem(key);\n            this._messageChannel(`Cannot restore state for Log4TSControlProvider '${this._provider.name}', data is not valid. Invalid data removed from localStorage.`);\n        }\n    }\n    help() {\n        const msg = `You can use the following commands (Log4TSProvider ${this._provider.name}):\\n` +\n            \"  showSettings()\\n\" +\n            \"    Shows the current configuration settings.\\n\" +\n            \"  update(logLevel: Log4TSControlProviderLogLevel, groupId?: number | string)\\n\" +\n            \"    Change the log level for one or all config groups.\\n\" +\n            \"      @param level   The log level to set - must be one of 'trace', 'debug', 'info', 'warn', 'error' or 'fatal'\\n\" +\n            \"      @param groupId Optional group config to update by either index or identifier, when omitted updates all groups.\\n\" +\n            \"                     Use showSettings() to find details about index and/or identifier.\\n\" +\n            \"  reset()\\n\" +\n            \"    Resets the log levels of the config groups back to when this control provider was created.\\n\" +\n            \"  save()\\n\" +\n            \"    Saves the current log levels for all config groups of this provider. Use restore() to load last saved state.\\n\" +\n            \"  restore()\\n\" +\n            \"    Restore stored saved state, if any. Log levels will be set according to saved state.\\n\" +\n            \"  help()\\n\" +\n            \"    Shows this help.\\n\";\n        this._messageChannel(msg);\n    }\n    restoreGroups(saveData, logCannotRestore) {\n        saveData.groups.forEach(group => {\n            try {\n                const newLevel = LogLevel.toLogLevel(group.level);\n                if (newLevel !== undefined) {\n                    this._provider.updateRuntimeSettingsGroup(group.identifier, { level: newLevel });\n                    this._messageChannel(`Log4TSControlProvider '${this._provider.name}' - restored log level of group '${group.identifier}' to '${LogLevel[newLevel]}'.`);\n                }\n                else {\n                    if (logCannotRestore) {\n                        this._messageChannel(`Log4TSControlProvider '${this._provider.name}' - failed to restore log level of group '${group.identifier}', invalid log level was specified.`);\n                    }\n                }\n            }\n            catch (e) {\n                if (logCannotRestore) {\n                    this._messageChannel(`Log4TSControlProvider '${this._provider.name}' - failed to restore log level of group '${group.identifier}'.`);\n                }\n            }\n        });\n    }\n    createKey() {\n        return `Log4TSProvider-${this._provider.name}`;\n    }\n    static loadCurrentGroupLogLevels(provider) {\n        return new Map(provider.groupConfigs.map(cfg => [cfg.identifier, cfg.level]));\n    }\n}\n\n/**\n * Provider for the Log4TS flavor, each provider is a unique instance that can be used to\n * get loggers from.\n */\nclass Log4TSProviderService {\n    constructor() {\n        this._log = InternalLogger.getInternalLogger(\"log4ts.impl.Log4TSProviderService\");\n        this._providers = new index.EnhancedMap();\n    }\n    createLogProvider(name, config) {\n        const result = this._providers.compute(name, (key, currentValue) => {\n            if (currentValue) {\n                throw new Error(`Log4TSProvider with name '${name}' already exists, cannot create another.`);\n            }\n            const mainConfig = mergeLog4TSConfigs(createDefaultLog4TSConfig(), config);\n            validateLog4TSConfig(mainConfig);\n            this._log.debug(() => `Creating new Log4TSProvider with name '${name}', using main config settings '${log4TSConfigDebug(mainConfig)}'.`);\n            const defaultExpression = new RegExp(\".+\");\n            const defaultGroupConfig = {\n                channel: mainConfig.channel,\n                level: mainConfig.level,\n                expression: defaultExpression,\n                dateFormatter: mainConfig.dateFormatter,\n                argumentFormatter: mainConfig.argumentFormatter,\n                identifier: defaultExpression.toString(),\n            };\n            return new Log4TSProviderImpl(key, defaultGroupConfig, mainConfig.groups);\n        });\n        // Cannot be undefined we do not allow it.\n        return result;\n    }\n    /**\n     * Clears all providers and configuration, the service reverts back to initial state.\n     */\n    clear() {\n        this._providers.clear();\n    }\n    getLog4TSControl(fnValue) {\n        const fnMessageChannel = fnValue ? fnValue : (value) => {\n            // tslint:disable-next-line:no-console\n            if (console && console.log) {\n                // tslint:disable-next-line:no-console\n                console.log(value);\n            }\n            else {\n                throw new Error(\"Cannot use console (it is not present), please specify a custom function to write to.\");\n            }\n        };\n        return {\n            help: () => fnMessageChannel(Log4TSProviderService.help()),\n            showSettings: () => fnMessageChannel(this.showSettings()),\n            getProvider: (id) => this.getLog4TSControlProviderByIdOrName(id, fnMessageChannel),\n        };\n    }\n    showSettings() {\n        let result = \"Available Log4TSProviders:\\n\";\n        const maxWidthIndex = this._providers.size.toString().length;\n        const maxWidthName = index.maxLengthStringValueInArray([...this._providers.keys()]);\n        const lines = [...this._providers.entries()].map((entry, index$1) => {\n            const name = entry[0];\n            /* [idx, name] */\n            return `  [${index.padStart(index$1.toString(), maxWidthIndex)}, ${index.padEnd(name, maxWidthName)}]`;\n        });\n        result += lines.join(\"\\n\") + (lines.length > 0 ? \"\\n\" : \"\");\n        return result;\n    }\n    getLog4TSControlProviderByIdOrName(id, messageChannel) {\n        if (typeof id === \"string\") {\n            const provider = this._providers.get(id);\n            if (provider === undefined) {\n                throw new Error(`Provider with name '${id}' does not exist.`);\n            }\n            return new Log4TSControlProviderImpl(provider, messageChannel);\n        }\n        const providers = [...this._providers.values()];\n        if (id < 0 || id >= providers.length) {\n            throw new Error(`Provider with index '${id}' does not exist (outside of range).`);\n        }\n        return new Log4TSControlProviderImpl(providers[id], messageChannel);\n    }\n    static help() {\n        return \"You can use the following commands:\\n\" +\n            \"  showSettings()\\n\" +\n            \"    Shows the current configuration settings.\\n\" +\n            \"  getProvider: (id: number | string): Log4TSControlProvider\\n\" +\n            \"    Get access to a Log4TSControlProvider to change log levels.\\n\" +\n            \"      @param id The id (use showSettings to see) or name of the provider\\n\" +\n            \"  help()\\n\" +\n            \"    Shows this help.\\n\";\n    }\n}\n/**\n * Singleton instance to the service, for internal usage only. Must NOT be exported to end user.\n */\nconst LOG4TS_PROVIDER_SERVICE = new Log4TSProviderService();\nconst LOG4TS_LOG_CONTROL = fnValue => LOG4TS_PROVIDER_SERVICE.getLog4TSControl(fnValue);\nfunction createDefaultLog4TSConfig() {\n    return {\n        argumentFormatter: formatArgument,\n        channel: DefaultChannels.createConsoleChannel(),\n        dateFormatter: formatDate,\n        groups: [],\n        level: LogLevel.Error,\n    };\n}\nfunction mergeLog4TSConfigs(lhs, rhs) {\n    const value = {\n        argumentFormatter: rhs.argumentFormatter ? rhs.argumentFormatter : lhs.argumentFormatter,\n        channel: rhs.channel ? rhs.channel : lhs.channel,\n        dateFormatter: rhs.dateFormatter ? rhs.dateFormatter : lhs.dateFormatter,\n        groups: [],\n        level: rhs.level !== undefined ? rhs.level : lhs.level,\n    };\n    /*\n     * Groups must take over the defaults from the main config when they don't specify config themselves.\n     */\n    value.groups = rhs.groups.map(groupConfig => mergeLog4TSGroupConfigs(value, groupConfig));\n    return value;\n}\nfunction mergeLog4TSGroupConfigs(lhs, rhs) {\n    return {\n        argumentFormatter: rhs.argumentFormatter ? rhs.argumentFormatter : lhs.argumentFormatter,\n        channel: lhs.channel,\n        dateFormatter: rhs.dateFormatter ? rhs.dateFormatter : lhs.dateFormatter,\n        expression: rhs.expression,\n        level: rhs.level !== undefined ? rhs.level : lhs.level,\n        identifier: rhs.identifier ? rhs.identifier : rhs.expression.toString(),\n    };\n}\nfunction validateLog4TSConfig(config) {\n    if (config.groups.length === 0) {\n        throw new Error(\"Invalid configuration, 'groups' on configuration is empty, at least 1 group config must be specified.\");\n    }\n}\n\n// tslint:disable-next-line:no-namespace\nvar Log4TSProvider;\n(function (Log4TSProvider) {\n    /**\n     * Creates a new log provider with given name and configuration. If a provider\n     * with such name already exists, an Error will be thrown.\n     * @param name Name for provider, must be unique\n     * @param config The config for the provider\n     */\n    function createProvider(name, config) {\n        return LOG4TS_PROVIDER_SERVICE.createLogProvider(name, config);\n    }\n    Log4TSProvider.createProvider = createProvider;\n    /**\n     * Resets and clears *all* created Log4TSProviders, every logger that was retrieved previously\n     * through any of them will be invalid afterwards.\n     *\n     * This call essentially reverts the created Log4TSProviders back to their initial state. This should normally not be used\n     * unless absolutely necessary.\n     */\n    function clear() {\n        LOG4TS_PROVIDER_SERVICE.clear();\n    }\n    Log4TSProvider.clear = clear;\n})(Log4TSProvider || (Log4TSProvider = {}));\n\nexport { LOG4TS_LOG_CONTROL, Log4TSProvider };\n//# sourceMappingURL=typescript-logging-log4ts.esm.js.map\n","\"use strict\";\n/*\n * StateMachine.ts\n * TypeScript finite state machine class with async transformations using promises.\n */\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _StateMachine_instances, _StateMachine_formatNoTransitionError;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StateMachine = void 0;\nexports.t = t;\nfunction t(fromState, event, toState, cb) {\n    return { fromState, event, toState, cb };\n}\nclass StateMachine {\n    // initialize the state-machine\n    constructor(init, transitions = [], logger = console) {\n        _StateMachine_instances.add(this);\n        this.init = init;\n        this.transitions = transitions;\n        this.logger = logger;\n        this._current = init;\n    }\n    addTransitions(transitions) {\n        // bind any unbound method\n        transitions.forEach((_tran) => {\n            const tran = Object.create(_tran);\n            if (tran.cb && !tran.cb.name?.startsWith(\"bound \")) {\n                tran.cb = tran.cb.bind(this);\n            }\n            this.transitions.push(tran);\n        });\n    }\n    getState() { return this._current; }\n    can(event) {\n        return this.transitions.some((trans) => (trans.fromState === this._current && trans.event === event));\n    }\n    getNextState(event) {\n        const transition = this.transitions.find((tran) => tran.fromState === this._current && tran.event === event);\n        return transition?.toState;\n    }\n    isFinal() {\n        // search for a transition that starts from current state.\n        // if none is found it's a terminal state.\n        return this.transitions.every((trans) => (trans.fromState !== this._current));\n    }\n    // post event async\n    async dispatch(event, ...args) {\n        return new Promise((resolve, reject) => {\n            // delay execution to make it async\n            setTimeout((me) => {\n                // find transition\n                const found = this.transitions.some((tran) => {\n                    if (tran.fromState === me._current && tran.event === event) {\n                        me._current = tran.toState;\n                        if (tran.cb) {\n                            try {\n                                const p = tran.cb(...args);\n                                if (p instanceof Promise) {\n                                    p.then(resolve).catch((e) => reject(e));\n                                }\n                                else {\n                                    resolve();\n                                }\n                            }\n                            catch (e) {\n                                this.logger.error(\"Exception caught in callback\", e);\n                                reject(e);\n                            }\n                        }\n                        else {\n                            resolve();\n                        }\n                        return true;\n                    }\n                    return false;\n                });\n                // no such transition\n                if (!found) {\n                    const errorMessage = __classPrivateFieldGet(this, _StateMachine_instances, \"m\", _StateMachine_formatNoTransitionError).call(this, me._current, event);\n                    this.logger.error(errorMessage);\n                    reject(new Error(errorMessage));\n                }\n            }, 0, this);\n        });\n    }\n    /**\n     * Generate a Mermaid StateDiagram of the current machine.\n     */\n    toMermaid(title) {\n        const diagram = [];\n        if (title) {\n            diagram.push(\"---\");\n            diagram.push(`title: ${title}`);\n            diagram.push(\"---\");\n        }\n        diagram.push(\"stateDiagram-v2\");\n        diagram.push(`  [*] --> ${String(this.init)}`);\n        this.transitions.forEach(({ event, fromState, toState }) => {\n            const from = String(fromState);\n            const to = String(toState);\n            const evt = String(event);\n            diagram.push(`  ${from} --> ${to}: ${evt}`);\n        });\n        // find terminal states\n        const ts = new Set();\n        this.transitions.forEach(({ toState }) => ts.add(toState));\n        this.transitions.forEach(({ fromState }) => ts.delete(fromState));\n        ts.forEach((state) => diagram.push(`  ${String(state)} --> [*]`));\n        return diagram.join(\"\\n\");\n    }\n}\nexports.StateMachine = StateMachine;\n_StateMachine_instances = new WeakSet(), _StateMachine_formatNoTransitionError = function _StateMachine_formatNoTransitionError(fromState, event) {\n    return `No transition: from ${String(fromState)} event ${String(event)}`;\n};\n//# sourceMappingURL=stateMachine.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/*--- config/LogConfig.ts ---*/\nimport { LogLevel } from \"typescript-logging\";\nimport { Log4TSProvider } from \"typescript-logging-log4ts-style\";\nexport const log4TSProvider = Log4TSProvider.createProvider(\"AwesomeLog4TSProvider\", {\n    level: LogLevel.Debug,\n    groups: [{\n            expression: new RegExp(\".+\"),\n        }]\n});\n","import { t, StateMachine } from \"typescript-fsm\";\nimport { log4TSProvider } from \"../../config/ConfigLog4j\";\nconst log = log4TSProvider.getLogger(\"EcoLLMStateMachine\");\nexport var States;\n(function (States) {\n    States[States[\"STARTING\"] = 0] = \"STARTING\";\n    States[States[\"READY\"] = 1] = \"READY\";\n    States[States[\"INFERENCE_ONGOING\"] = 2] = \"INFERENCE_ONGOING\";\n})(States || (States = {}));\nexport var Events;\n(function (Events) {\n    Events[Events[\"ADD_LISTENER\"] = 100] = \"ADD_LISTENER\";\n    Events[Events[\"START_INFERENCE\"] = 101] = \"START_INFERENCE\";\n    Events[Events[\"FINISH_INFERENCE\"] = 102] = \"FINISH_INFERENCE\";\n})(Events || (Events = {}));\nexport class EcoLLMStateMachine {\n    constructor(onAddListener) {\n        const transitions = [\n            /* fromState        event                 toState         callback */\n            t(States.STARTING, Events.ADD_LISTENER, States.READY, (payload) => {\n                log.debug(\"Transition: STARTING -> READY\");\n                if (onAddListener) {\n                    onAddListener(payload);\n                }\n            }),\n            t(States.READY, Events.START_INFERENCE, States.INFERENCE_ONGOING, () => {\n                log.debug(\"Transition: READY -> INFERENCE_ONGOING\");\n            }),\n            t(States.INFERENCE_ONGOING, Events.FINISH_INFERENCE, States.READY, () => {\n                log.debug(\"Transition: INFERENCE_ONGOING -> READY\");\n            }),\n        ];\n        this.machine = new StateMachine(States.STARTING, transitions);\n    }\n    dispatch(event, payload) {\n        if (this.machine.can(event)) {\n            try {\n                this.machine.dispatch(event, payload);\n            }\n            catch (error) {\n                log.warn(`Error dispatching event ${Events[event]} from state ${States[this.machine.getState()]}: ${error}`);\n            }\n        }\n        else {\n            log.warn(`Cannot dispatch event ${Events[event]} from state ${States[this.machine.getState()]}`);\n        }\n    }\n    getState() {\n        return this.machine.getState();\n    }\n}\n","import { log4TSProvider } from \"../config/ConfigLog4j\";\nimport { EcoLLMStateMachine, States, Events } from \"./common/EcoLLMStateMachine\";\nconst log = log4TSProvider.getLogger(\"content-script-copilot.ts\");\n// Initialize the state machine first\nconst states = new EcoLLMStateMachine();\nvar chatEventStartDate = null;\n// Called when a new inference is starting (form submit or button click)\nconst onInferenceStarting = () => {\n    chatEventStartDate = Date.now();\n    states.dispatch(Events.START_INFERENCE);\n    log.debug(\"Copilot inference starting!\");\n};\n// Track the last processed message to avoid duplicates\nlet lastProcessedMessageHash = null;\n// Function to extract model name from Copilot UI\nfunction extractModelName() {\n    // The model selector button shows \"Smart (GPT-5)\" or similar\n    const modelButton = document.querySelector('[data-testid=\"composer-chat-mode-smart-button\"]') ||\n        document.querySelector('[data-testid*=\"chat-mode\"]') ||\n        document.querySelector('button[title*=\"GPT\"]');\n    let selectedModelString = \"gpt-4\";\n    if (modelButton) {\n        const modelText = modelButton.textContent || modelButton.getAttribute('title') || '';\n        log.debug('Copilot model button text: ' + modelText);\n        // Extract model from text like \"Smart (GPT-5)\" or \"GPT-5\"\n        const modelMatch = modelText.match(/GPT[-\\s]?(\\d+)/i) || modelText.match(/(gpt[-\\s]?\\d+)/i);\n        if (modelMatch) {\n            selectedModelString = modelMatch[0].toLowerCase().replace(/\\s+/g, '-');\n            if (!selectedModelString.startsWith('gpt-')) {\n                selectedModelString = 'gpt-' + selectedModelString.replace('gpt', '').trim();\n            }\n        }\n        else if (modelText.toLowerCase().includes('smart')) {\n            // Default to GPT-4 for \"Smart\" mode\n            selectedModelString = \"gpt-4\";\n        }\n    }\n    return selectedModelString;\n}\n// Function to find AI messages in Copilot's DOM\nfunction findAIMessages() {\n    // Look for AI message containers - Copilot uses data-content=\"ai-message\"\n    const aiMessageContainers = document.querySelectorAll('[data-content=\"ai-message\"]');\n    if (aiMessageContainers.length > 0) {\n        return aiMessageContainers;\n    }\n    // Fallback: Also look for messages that have the reactions element (indicates complete message)\n    const messagesWithReactions = document.querySelectorAll('[data-testid=\"message-item-reactions\"]');\n    const messageContainers = [];\n    // Get parent message containers for reactions\n    messagesWithReactions.forEach((reactions) => {\n        // Find the parent message container (usually a few levels up)\n        let parent = reactions.parentElement;\n        let depth = 0;\n        while (parent && depth < 6) {\n            // Look for the AI message container\n            if (parent.getAttribute('data-content') === 'ai-message' ||\n                parent.classList.toString().includes('ai-message') ||\n                parent.querySelector('[data-content=\"ai-message\"]')) {\n                messageContainers.push(parent);\n                break;\n            }\n            parent = parent.parentElement;\n            depth++;\n        }\n    });\n    // Also try direct selectors as fallback\n    const directMessages = document.querySelectorAll('[data-content=\"ai-message\"], ' +\n        '[data-testid*=\"ai-message\"], ' +\n        '[class*=\"group/ai-message\"], ' +\n        '[class*=\"ai-message\"]');\n    // Combine and return unique elements\n    const allMessages = new Set([...Array.from(messageContainers), ...Array.from(directMessages)]);\n    return Array.from(allMessages);\n}\n// Function to check if message is still streaming\nfunction isStreaming(messageElement) {\n    // Look for streaming indicators\n    return !!(messageElement.querySelector('.streaming-animation') ||\n        messageElement.querySelector('[class*=\"streaming\"]') ||\n        messageElement.querySelector('[class*=\"typing\"]') ||\n        messageElement.querySelector('[class*=\"loading\"]') ||\n        messageElement.getAttribute('aria-busy') === 'true');\n}\n// Function to wait for all animations/transitions to finish on an element\nfunction waitForAnimations(element) {\n    return new Promise((resolve) => {\n        const animations = [];\n        const transitions = [];\n        // Find all elements with animations or transitions\n        const allElements = [element, ...Array.from(element.querySelectorAll('*'))];\n        allElements.forEach((el) => {\n            const computedStyle = window.getComputedStyle(el);\n            const animationName = computedStyle.animationName;\n            const transitionProperty = computedStyle.transitionProperty;\n            // Check for CSS animations\n            if (animationName && animationName !== 'none') {\n                const animationPromise = new Promise((animResolve) => {\n                    const handleAnimationEnd = (e) => {\n                        if (e.target === el) {\n                            el.removeEventListener('animationend', handleAnimationEnd);\n                            animResolve();\n                        }\n                    };\n                    el.addEventListener('animationend', handleAnimationEnd);\n                });\n                animations.push(animationPromise);\n            }\n            // Check for CSS transitions (especially opacity transitions)\n            if (transitionProperty && transitionProperty !== 'none') {\n                const transitionPromise = new Promise((transResolve) => {\n                    const handleTransitionEnd = (e) => {\n                        if (e.target === el && (e.propertyName === 'opacity' || e.propertyName === 'all')) {\n                            el.removeEventListener('transitionend', handleTransitionEnd);\n                            transResolve();\n                        }\n                    };\n                    el.addEventListener('transitionend', handleTransitionEnd);\n                });\n                transitions.push(transitionPromise);\n            }\n        });\n        // If no animations or transitions found, resolve immediately\n        if (animations.length === 0 && transitions.length === 0) {\n            resolve();\n            return;\n        }\n        // Wait for all animations and transitions to complete\n        Promise.all([...animations, ...transitions]).then(() => {\n            // Add a small delay to ensure everything is fully rendered\n            setTimeout(resolve, 100);\n        });\n        // Fallback timeout in case animations don't fire (max 5 seconds wait)\n        setTimeout(() => {\n            resolve();\n        }, 5000);\n    });\n}\n// Function to extract text from a message element\nfunction extractMessageText(messageElement) {\n    // Try to find the content container - prioritize ID selector, then class selector\n    let contentContainer = messageElement.querySelector('[id*=\"-content-\"]');\n    if (!contentContainer) {\n        // Fallback: try class selector for \"group/ai-message-item\"\n        contentContainer = messageElement.querySelector('[class*=\"group/ai-message-item\"]');\n    }\n    if (contentContainer) {\n        // textContent gets all text regardless of CSS opacity\n        return contentContainer.textContent || contentContainer.innerText || '';\n    }\n    // Final fallback: use entire message but exclude screen reader elements\n    const clone = messageElement.cloneNode(true);\n    clone.querySelectorAll('.sr-only, [class*=\"sr-only\"]').forEach(el => el.remove());\n    return clone.textContent || clone.innerText || '';\n}\n// Function to process a completed message\nasync function processCompletedMessage() {\n    if (states.getState() !== States.INFERENCE_ONGOING || !chatEventStartDate) {\n        return;\n    }\n    const aiMessages = findAIMessages();\n    if (aiMessages.length === 0) {\n        return;\n    }\n    // Get the last AI message (most recent response)\n    const lastMessage = aiMessages[aiMessages.length - 1];\n    // Check if still streaming\n    if (isStreaming(lastMessage)) {\n        log.debug('Copilot message still streaming, waiting...');\n        return;\n    }\n    // Find the content container to wait for animations\n    let contentContainer = lastMessage.querySelector('[id*=\"-content-\"]');\n    if (!contentContainer) {\n        contentContainer = lastMessage.querySelector('[class*=\"group/ai-message-item\"]');\n    }\n    // If we found a content container, wait for all animations to finish\n    if (contentContainer) {\n        log.debug('Copilot waiting for animations to finish...');\n        await waitForAnimations(contentContainer);\n    }\n    // Re-check state after waiting\n    if (states.getState() !== States.INFERENCE_ONGOING || !chatEventStartDate) {\n        return;\n    }\n    // Re-get messages in case DOM changed\n    const currentMessages = findAIMessages();\n    if (currentMessages.length === 0) {\n        return;\n    }\n    const finalMessage = currentMessages[currentMessages.length - 1];\n    // Extract text content\n    const messageText = extractMessageText(finalMessage).trim();\n    if (!messageText || messageText === 'Copilot said') {\n        log.debug('Copilot: No valid text found in message');\n        return;\n    }\n    // Create a hash to avoid processing the same message twice\n    const messageHash = messageText.substring(0, 100) + messageText.length;\n    if (messageHash === lastProcessedMessageHash) {\n        return;\n    }\n    lastProcessedMessageHash = messageHash;\n    log.debug('Copilot inference done!');\n    log.debug('Copilot extracted text length: ' + messageText.length);\n    const selectedModelString = extractModelName();\n    log.debug('Copilot model selected: ' + selectedModelString);\n    const raw = {\n        url: document.location.href,\n        body: \"{\\\"model\\\":\\\"\" + selectedModelString + \"\\\"}\",\n        generated_text: messageText,\n        starttime: chatEventStartDate,\n        latency: Date.now() - chatEventStartDate,\n    };\n    chrome.runtime.sendMessage(raw);\n    chatEventStartDate = null;\n    states.dispatch(Events.FINISH_INFERENCE);\n}\n// Debounce function to avoid processing too frequently\nlet processTimeout = null;\nfunction debounceProcessCompletedMessage(delay = 500) {\n    if (processTimeout) {\n        clearTimeout(processTimeout);\n    }\n    processTimeout = setTimeout(() => {\n        processCompletedMessage();\n    }, delay);\n}\n// Wait for any DOM element to be changed\nconst observer = new MutationObserver((mutationsList) => {\n    if (states.getState() !== States.INFERENCE_ONGOING) {\n        return;\n    }\n    let hasRelevantChanges = false;\n    for (const mutation of mutationsList) {\n        if (mutation.type === 'childList') {\n            mutation.addedNodes.forEach((node) => {\n                var _a, _b, _c, _d, _e;\n                if (node.nodeType === Node.ELEMENT_NODE) {\n                    const element = node;\n                    // Check if this is a content container or reactions element (indicates message completion)\n                    if (((_a = element.classList) === null || _a === void 0 ? void 0 : _a.contains('group/ai-message-item')) ||\n                        ((_b = element.id) === null || _b === void 0 ? void 0 : _b.includes('-content-')) ||\n                        ((_c = element.getAttribute) === null || _c === void 0 ? void 0 : _c.call(element, 'data-testid')) === 'message-item-reactions' ||\n                        ((_d = element.querySelector) === null || _d === void 0 ? void 0 : _d.call(element, '[data-testid=\"message-item-reactions\"]')) ||\n                        ((_e = element.querySelector) === null || _e === void 0 ? void 0 : _e.call(element, '[class*=\"group/ai-message-item\"]'))) {\n                        hasRelevantChanges = true;\n                    }\n                }\n                else if (node.nodeType === Node.TEXT_NODE) {\n                    const textContent = node.textContent || '';\n                    if (textContent.trim().length > 0) {\n                        hasRelevantChanges = true;\n                    }\n                }\n            });\n        }\n        // Also check for text changes (streaming updates)\n        if (mutation.type === 'characterData') {\n            hasRelevantChanges = true;\n        }\n    }\n    // If there were relevant changes, debounce the processing\n    if (hasRelevantChanges) {\n        debounceProcessCompletedMessage();\n    }\n});\nobserver.observe(document.body, { childList: true, subtree: true, characterData: true });\n/**\n * Returns the main editor element (textarea) for Copilot.\n */\nfunction getEditor(root = document) {\n    // Copilot uses textarea#userInput\n    return root.querySelector('textarea#userInput');\n}\n/**\n * Safely extracts the current message text from the editor.\n */\nfunction getCurrentMessage(root = document) {\n    var _a;\n    const editor = getEditor(root);\n    if (!editor)\n        return '';\n    return editor.value.trim() || ((_a = editor.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';\n}\n/**\n * Install listeners on the given document (top-level or iframe).\n */\nfunction installPromptListeners(rootDoc) {\n    // Avoid installing twice\n    const markerId = '__extension_copilot_prompt_listeners_installed__';\n    if (rootDoc[markerId])\n        return;\n    rootDoc[markerId] = true;\n    console.log('[Extension] Installing Copilot prompt listeners on', rootDoc === document ? 'top document' : 'iframe');\n    // 1) Capture clicks on the send button\n    rootDoc.addEventListener('click', (event) => {\n        const target = event.target;\n        if (!target)\n            return;\n        // Look for send button - Copilot might use different selectors\n        // Check for button that submits the form or has send-related attributes\n        const btn = target.closest('button[type=\"submit\"]') ||\n            target.closest('button[aria-label*=\"send\" i]') ||\n            target.closest('button[title*=\"send\" i]') ||\n            target.closest('[data-testid*=\"send\"]');\n        if (!btn)\n            return;\n        const message = getCurrentMessage(rootDoc);\n        if (!message)\n            return;\n        log.debug('Copilot send button clicked');\n        onInferenceStarting();\n    }, true);\n    // 2) Capture Enter / Ctrl+Enter in the textarea (keyboard submission)\n    rootDoc.addEventListener('keydown', (event) => {\n        const target = event.target;\n        if (!target)\n            return;\n        // Only care about keydown events inside the textarea\n        const editor = target.closest('textarea#userInput');\n        if (!editor)\n            return;\n        const isEnter = event.key === 'Enter';\n        if (!isEnter)\n            return;\n        const isPlainEnter = !event.shiftKey && !event.altKey && !event.ctrlKey && !event.metaKey;\n        const isCtrlEnter = event.ctrlKey || event.metaKey;\n        if (!isPlainEnter && !isCtrlEnter)\n            return;\n        const message = getCurrentMessage(rootDoc);\n        if (!message)\n            return;\n        log.debug('Copilot Enter key pressed');\n        onInferenceStarting();\n    }, true);\n    // 3) Capture form submit\n    rootDoc.addEventListener('submit', (event) => {\n        var _a;\n        const target = event.target;\n        if (!target)\n            return;\n        // Look for form containing the textarea\n        const form = target.closest('form') ||\n            ((_a = getEditor(rootDoc)) === null || _a === void 0 ? void 0 : _a.closest('form'));\n        if (!form)\n            return;\n        const message = getCurrentMessage(rootDoc);\n        if (!message)\n            return;\n        log.debug('Copilot form submitted');\n        onInferenceStarting();\n    }, true);\n}\n/**\n * Optionally handle iframes as well (if the chat UI is inside an iframe).\n */\nfunction installOnAllDocuments() {\n    var _a;\n    // Install on top-level document\n    installPromptListeners(document);\n    // Try to install on same-origin iframes, if any.\n    const iframes = Array.from(document.querySelectorAll('iframe'));\n    for (const iframe of iframes) {\n        try {\n            const iframeDoc = iframe.contentDocument || ((_a = iframe.contentWindow) === null || _a === void 0 ? void 0 : _a.document) || null;\n            if (iframeDoc) {\n                installPromptListeners(iframeDoc);\n            }\n        }\n        catch (_b) {\n            // Cross-origin iframe  ignore\n        }\n    }\n}\n// Run immediately when the content script executes\ninstallOnAllDocuments();\n// Initialize the state machine listener\nstates.dispatch(Events.ADD_LISTENER);\nlog.debug(\"content-script-copilot.ts: Content script loaded!\");\n"],"names":["InternalLogLevel","LogLevel","DefaultChannels","_StateMachine_instances","_StateMachine_formatNoTransitionError","__classPrivateFieldGet","this","receiver","state","kind","f","TypeError","has","call","value","get","Object","defineProperty","exports","StateMachine","t","fromState","event","toState","cb","constructor","init","transitions","logger","console","add","_current","addTransitions","forEach","_tran","tran","create","name","startsWith","bind","push","getState","can","some","trans","getNextState","transition","find","isFinal","every","dispatch","args","Promise","resolve","reject","setTimeout","me","p","then","catch","e","error","errorMessage","Error","toMermaid","title","diagram","String","from","to","evt","ts","Set","delete","join","WeakSet","__webpack_module_cache__","EnhancedMap","Map","computeIfAbsent","key","computer","newValue","set","computeIfPresent","currentValue","undefined","compute","InternalLoggerImpl","level","fnOutput","_name","_level","_fnOutput","trace","msg","log","Trace","debug","Debug","info","Info","warn","Warn","setLevel","setOutput","toString","stack","InternalProviderImpl","_loggers","_logLevel","logConsole","getLogger","changeLogLevel","changeOutput","reset","toLogLevel","val","toLowerCase","Fatal","Off","ConsoleLogChannel","type","write","message","createConsoleChannel","setInternalLogLevel","freeze","__proto__","INTERNAL_LOGGING_SETTINGS","getInternalLogger","runtime","_runtime","id","logLevel","runtimeSettings","assign","logMessage","fatal","logMessageType","nowMillis","Date","now","errorAndArgs","getErrorAndArgs","channel","exception","timeInMillis","logNames","argumentFormatter","createLogMessage","formatArgValue","errorResult","dateFormatted","dateFormatter","levelAsStr","toUpperCase","length","map","arg","actualArgs","value0","slice","errorOrArgs","Array","isArray","fillChar","padType","charsNeeded","padding","i","JSON","stringify","millisSinceEpoch","date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","settings","_log","_settings","_idToKeyMap","_globalRuntimeSettings","_nextLoggerId","getOrCreateLogger","updateLoggerRuntime","currentKey","mergeRuntimeSettingsIntoLogRuntime","updateRuntimeSettings","clear","createKey","nextLoggerId","result","currentSettings","maxLengthStringValueInArray","arr","v","reduce","previous","current","padEnd","padStart","log4TSGroupConfigDebug","config","expression","Log4TSProviderImpl","defaultConfig","groupConfigs","_defaultConfig","identifier","_logProviders","updatedConfig","provider","groupConfig","groupProvLog","values","test","updateRuntimeSettingsGroup","updateLog4TGroupConfig","cfg","Log4TSControlProviderImpl","messageChannel","_provider","_messageChannel","_originalLogLevels","loadCurrentGroupLogLevels","showSettings","channelDescription","maxWidthIndex","maxWidthIdentifier","index$1","update","groupId","newLevel","groups","expectedGroup","save","localStorage","data","setItem","restore","logRestoreFailures","finalLogRestoreFailures","getItem","savedData","parse","restoreGroups","removeItem","help","saveData","logCannotRestore","group","Log4TSProviderService","_providers","createLogProvider","mainConfig","lhs","rhs","mergeLog4TSGroupConfigs","mergeLog4TSConfigs","validateLog4TSConfig","groupLog","g","log4TSConfigDebug","defaultExpression","RegExp","defaultGroupConfig","getLog4TSControl","fnValue","fnMessageChannel","getProvider","getLog4TSControlProviderByIdOrName","size","maxWidthName","keys","lines","entries","entry","providers","LOG4TS_PROVIDER_SERVICE","Log4TSProvider","createProvider","log4TSProvider","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","States","Events","states","onAddListener","STARTING","ADD_LISTENER","READY","payload","START_INFERENCE","INFERENCE_ONGOING","FINISH_INFERENCE","machine","chatEventStartDate","onInferenceStarting","lastProcessedMessageHash","findAIMessages","aiMessageContainers","document","querySelectorAll","messagesWithReactions","messageContainers","reactions","parent","parentElement","depth","getAttribute","classList","includes","querySelector","directMessages","allMessages","processTimeout","getEditor","root","getCurrentMessage","_a","editor","trim","textContent","installPromptListeners","rootDoc","markerId","addEventListener","target","closest","isPlainEnter","shiftKey","altKey","ctrlKey","metaKey","isCtrlEnter","MutationObserver","mutationsList","hasRelevantChanges","mutation","addedNodes","node","_b","_c","_d","_e","nodeType","Node","ELEMENT_NODE","element","contains","TEXT_NODE","delay","clearTimeout","async","aiMessages","lastMessage","messageElement","contentContainer","animations","el","computedStyle","window","getComputedStyle","animationName","transitionProperty","animationPromise","animResolve","handleAnimationEnd","removeEventListener","transitionPromise","transResolve","handleTransitionEnd","propertyName","all","currentMessages","messageText","innerText","clone","cloneNode","remove","extractMessageText","messageHash","substring","selectedModelString","modelButton","modelText","modelMatch","match","replace","extractModelName","raw","url","location","href","body","generated_text","starttime","latency","chrome","sendMessage","processCompletedMessage","debounceProcessCompletedMessage","observe","childList","subtree","characterData","iframes","iframe","iframeDoc","contentDocument","contentWindow","installOnAllDocuments"],"sourceRoot":""}