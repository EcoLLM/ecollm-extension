{"version":3,"file":"content-script-chat-ecollm.js","mappings":"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","sources":["webpack://ecollm-chrome-extension/./node_modules/typescript-logging/dist/bundle/typescript-logging.esm.js","webpack://ecollm-chrome-extension/./node_modules/typescript-logging-log4ts-style/dist/bundle/typescript-logging-log4ts.esm.js","webpack://ecollm-chrome-extension/./node_modules/typescript-fsm/dist/stateMachine.js","webpack://ecollm-chrome-extension/webpack/bootstrap","webpack://ecollm-chrome-extension/./src/config/ConfigLog4j.ts","webpack://ecollm-chrome-extension/./src/content-scripts/content-script-chat-ecollm.ts"],"sourcesContent":["/**\n * Extends Map and adds a few convenient functions.\n */\nclass EnhancedMap extends Map {\n    /**\n     * If key has a mapping already returns the currently associated value. If\n     * there is no mapping, calls the computer which must return a value V.\n     * The value is then stored for given key and returned.\n     * @param key Key\n     * @param computer Computer which is called only if key has no mapping yet.\n     * @return Existing value if the key already existed, or the newly computed value.\n     */\n    computeIfAbsent(key, computer) {\n        if (this.has(key)) {\n            return this.get(key);\n        }\n        const newValue = computer(key);\n        this.set(key, newValue);\n        return newValue;\n    }\n    /**\n     * If the key exists already calls given computer, if the key does not exist\n     * this method does nothing.\n     *\n     * The computer is called with current key and current value associated. The\n     * computer can return a (new) value V or undefined. When undefined is returned\n     * the key is removed from this map, when a V is returned the key is updated\n     * with the new value V.\n     * @param key Key\n     * @param computer Computer which is called only if the key has a mapping already\n     * @return Undefined if the key has no mapping, otherwise the value returned from computer\n     */\n    computeIfPresent(key, computer) {\n        const currentValue = this.get(key);\n        if (currentValue === undefined) {\n            return undefined;\n        }\n        const newValue = computer(key, currentValue);\n        if (newValue !== undefined) {\n            this.set(key, newValue);\n        }\n        else {\n            this.delete(key);\n        }\n        return newValue;\n    }\n    /**\n     * Computes a value for given key, the computer can return a value V (in which case the map\n     * will set the value for given key), if it returns undefined the mapping for key K will be\n     * removed.\n     * @param key Key to compute\n     * @param computer Computer which is called, note that the currentValue argument contains the existing\n     *                 value or is undefined when no mapping exists for the key.\n     * @return The newly computed value\n     */\n    compute(key, computer) {\n        const currentValue = this.get(key);\n        const newValue = computer(key, currentValue);\n        if (newValue) {\n            this.set(key, newValue);\n        }\n        else {\n            this.delete(key);\n        }\n        return newValue;\n    }\n}\n\n/**\n * Internal log level (note: do NOT use LogLevel, or we get circular loading issues!)\n */\nvar InternalLogLevel;\n(function (InternalLogLevel) {\n    InternalLogLevel[InternalLogLevel[\"Trace\"] = 0] = \"Trace\";\n    InternalLogLevel[InternalLogLevel[\"Debug\"] = 1] = \"Debug\";\n    InternalLogLevel[InternalLogLevel[\"Info\"] = 2] = \"Info\";\n    InternalLogLevel[InternalLogLevel[\"Warn\"] = 3] = \"Warn\";\n    InternalLogLevel[InternalLogLevel[\"Error\"] = 4] = \"Error\";\n})(InternalLogLevel || (InternalLogLevel = {}));\n/**\n * Internal logger, this is NOT for end users. Instead this is used to enable logging for typescript-logging itself in case of problems.\n *\n * @param name Name of logger\n */\nfunction getInternalLogger(name) {\n    return provider.getLogger(name);\n}\n/**\n * Can be used to change the *internal* logging of the library.\n * Has no effect on end user logging.\n *\n * As such should normally not be used by end users.\n */\nconst INTERNAL_LOGGING_SETTINGS = {\n    /**\n     * Changes the log level for the internal logging (for all new and existing loggers)\n     * @param level New log level\n     */\n    setInternalLogLevel: (level) => provider.changeLogLevel(level),\n    /**\n     * Changes where messages are written to for all new and existing loggers),\n     * by default they are written to the console.\n     * @param fnOutput Function to write messages to\n     */\n    setOutput: (fnOutput) => provider.changeOutput(fnOutput),\n    /**\n     * Resets the log level and output back to defaults (level to error and writing to console)\n     * for all new and existing loggers.\n     */\n    reset: () => provider.reset(),\n};\nclass InternalLoggerImpl {\n    constructor(name, level, fnOutput) {\n        this._name = name;\n        this._level = level;\n        this._fnOutput = fnOutput;\n    }\n    trace(msg) {\n        this.log(InternalLogLevel.Trace, msg);\n    }\n    debug(msg) {\n        this.log(InternalLogLevel.Debug, msg);\n    }\n    error(msg, error) {\n        this.log(InternalLogLevel.Error, msg, error);\n    }\n    info(msg) {\n        this.log(InternalLogLevel.Info, msg);\n    }\n    warn(msg, error) {\n        this.log(InternalLogLevel.Warn, msg, error);\n    }\n    setLevel(level) {\n        this._level = level;\n    }\n    setOutput(fnOutput) {\n        this._fnOutput = fnOutput;\n    }\n    log(level, msg, error) {\n        if (this._level > level) {\n            return;\n        }\n        // tslint:disable-next-line:no-console\n        this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${msg()}${error ? \"\\n\" + error.stack : \"\"}`);\n    }\n}\nclass InternalProviderImpl {\n    constructor() {\n        this._loggers = new EnhancedMap();\n        this._logLevel = InternalLogLevel.Error;\n        this._fnOutput = InternalProviderImpl.logConsole;\n    }\n    getLogger(name) {\n        return this._loggers.computeIfAbsent(name, key => new InternalLoggerImpl(key, this._logLevel, this._fnOutput));\n    }\n    changeLogLevel(level) {\n        this._logLevel = level;\n        this._loggers.forEach(logger => logger.setLevel(level));\n    }\n    changeOutput(_fnOutput) {\n        this._fnOutput = _fnOutput;\n        this._loggers.forEach(logger => logger.setOutput(this._fnOutput));\n    }\n    reset() {\n        this.changeLogLevel(InternalLogLevel.Error);\n        this._fnOutput = InternalProviderImpl.logConsole;\n        this._loggers.forEach(logger => logger.setOutput(this._fnOutput));\n    }\n    static logConsole(msg) {\n        // tslint:disable-next-line:no-console\n        if (console && console.log) {\n            // tslint:disable-next-line:no-console\n            console.log(msg);\n        }\n    }\n}\nconst provider = new InternalProviderImpl();\n\nvar InternalLogger = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS,\n  get InternalLogLevel () { return InternalLogLevel; },\n  getInternalLogger: getInternalLogger\n});\n\n/**\n * Log level for a logger.\n */\nvar LogLevel;\n(function (LogLevel) {\n    // Do not change values/order. Logging a message relies on this.\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 3] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n    LogLevel[LogLevel[\"Fatal\"] = 5] = \"Fatal\";\n    LogLevel[LogLevel[\"Off\"] = 6] = \"Off\";\n})(LogLevel || (LogLevel = {}));\n/* tslint:disable:no-namespace */\n(function (LogLevel) {\n    /**\n     * Convert given value to LogLevel, if not matching returns undefined.\n     * @param val Value to convert\n     */\n    function toLogLevel(val) {\n        switch (val.toLowerCase()) {\n            case \"trace\":\n                return LogLevel.Trace;\n            case \"debug\":\n                return LogLevel.Debug;\n            case \"info\":\n                return LogLevel.Info;\n            case \"warn\":\n                return LogLevel.Warn;\n            case \"error\":\n                return LogLevel.Error;\n            case \"fatal\":\n                return LogLevel.Fatal;\n            case \"off\":\n                return LogLevel.Off;\n            default:\n                return undefined;\n        }\n    }\n    LogLevel.toLogLevel = toLogLevel;\n})(LogLevel || (LogLevel = {}));\n/* tslint:disable:enable-namespace */\n\n/**\n * Standard logger implementation that provides the basis for all loggers.\n */\nclass CoreLoggerImpl {\n    constructor(runtime) {\n        this._runtime = runtime;\n    }\n    get id() {\n        return this._runtime.id;\n    }\n    get logLevel() {\n        return this._runtime.level;\n    }\n    get runtimeSettings() {\n        /* Return it as new literal, we don't want people to play with our internal state */\n        return Object.assign({}, this._runtime);\n    }\n    set runtimeSettings(runtime) {\n        this._runtime = runtime;\n    }\n    trace(message, ...args) {\n        this.logMessage(LogLevel.Trace, message, args);\n    }\n    debug(message, ...args) {\n        this.logMessage(LogLevel.Debug, message, args);\n    }\n    info(message, ...args) {\n        this.logMessage(LogLevel.Info, message, args);\n    }\n    warn(message, ...args) {\n        this.logMessage(LogLevel.Warn, message, args);\n    }\n    error(message, ...args) {\n        this.logMessage(LogLevel.Error, message, args);\n    }\n    fatal(message, ...args) {\n        this.logMessage(LogLevel.Fatal, message, args);\n    }\n    logMessage(level, logMessageType, args) {\n        if (this._runtime.level > level) {\n            return;\n        }\n        const nowMillis = Date.now();\n        const message = typeof logMessageType === \"string\" ? logMessageType : logMessageType();\n        const errorAndArgs = CoreLoggerImpl.getErrorAndArgs(args);\n        /*\n         * Deal with raw message here.\n         */\n        switch (this._runtime.channel.type) {\n            case \"RawLogChannel\":\n                this._runtime.channel.write({\n                    message,\n                    exception: errorAndArgs.error,\n                    args: errorAndArgs.args,\n                    timeInMillis: nowMillis,\n                    level,\n                    logNames: this._runtime.name,\n                }, this._runtime.argumentFormatter);\n                return;\n            case \"LogChannel\":\n                this._runtime.channel.write(this.createLogMessage(message, level, errorAndArgs, nowMillis));\n                break;\n        }\n    }\n    formatArgValue(value) {\n        try {\n            return this._runtime.argumentFormatter(value);\n        }\n        catch (e) {\n            // We don't really care what failed, except that the convert function failed.\n            return `>>ARG CONVERT FAILED: '${value !== undefined ? value.toString() : \"undefined\"}'<<`;\n        }\n    }\n    createLogMessage(message, level, errorAndArgs, nowMillis) {\n        let errorResult;\n        const error = errorAndArgs.error;\n        const args = errorAndArgs.args;\n        if (error) {\n            errorResult = `${error.name}: ${error.message}`;\n            if (error.stack) {\n                errorResult += `@\\n${error.stack}`;\n            }\n        }\n        /*\n         * We need to add the date, and log names (in front of the now formatted message).\n         * Finally we also need to format any additional arguments and append after the message.\n         */\n        const dateFormatted = this._runtime.dateFormatter(nowMillis);\n        let levelAsStr = LogLevel[level].toUpperCase();\n        if (levelAsStr.length < 5) {\n            levelAsStr += \" \";\n        }\n        const names = typeof this._runtime.name === \"string\" ? this._runtime.name : this._runtime.name.join(\", \");\n        const argsFormatted = typeof args !== \"undefined\" && args.length > 0 ? (\" [\" + (args.map(arg => this.formatArgValue(arg))).join(\", \") + \"]\") : \"\";\n        const completedMessage = dateFormatted + \" \" + levelAsStr + \" [\" + names + \"] \" + message + argsFormatted;\n        return {\n            message: completedMessage,\n            error: errorResult,\n        };\n    }\n    static getErrorAndArgs(args) {\n        /*\n          The args are optional, but the first entry may be an Error or a function to an Error, or finally be a function to extra arguments.\n          The last is only true, if the length of args === 1, otherwise we expect args starting at pos 1 and further to be just that - args.\n         */\n        if (args.length === 0) {\n            return {};\n        }\n        let error;\n        let actualArgs;\n        const value0 = args[0];\n        /* If the first argument is an Error, we can stop straight away, the rest are additional arguments then if any */\n        if (value0 instanceof Error) {\n            error = value0;\n            actualArgs = args.length > 1 ? args.slice(1) : undefined;\n            return { error, args: actualArgs };\n        }\n        /* If the first argument is a function, it means either it will return the Error, or if the array length === 1 a function, returning the arguments */\n        if (typeof value0 === \"function\") {\n            const errorOrArgs = value0();\n            if (errorOrArgs instanceof Error) {\n                error = errorOrArgs;\n                actualArgs = args.length > 1 ? args.slice(1) : undefined;\n                return { error, args: actualArgs };\n            }\n            if (args.length === 1) {\n                /* The first argument was a function, we assume it returned the extra argument(s) */\n                if (Array.isArray(errorOrArgs)) {\n                    return { args: errorOrArgs.length > 0 ? errorOrArgs : undefined };\n                }\n                else {\n                    /* No idea what was returned we just assume a single value */\n                    return { args: errorOrArgs };\n                }\n            }\n            else {\n                /*\n                  This is a weird situation but there's no way to avoid it, the first argument was a function but did not return an Error and the args are > 1,\n                  so just add the args returned, as well as any remaining.\n                */\n                if (Array.isArray(errorOrArgs)) {\n                    return { args: [...errorOrArgs, ...args.slice(1)] };\n                }\n                return { args: [errorOrArgs, ...args.slice(1)] };\n            }\n        }\n        /* All args are ordinary arguments, or at least the first arg was not an Error or a Function, so we add all as args */\n        return { args };\n    }\n}\n\n/**\n * Pad given value with given fillChar from the beginning (default is an empty space)\n * @param value Value to pad\n * @param length The length the string must be\n * @param fillChar The padding char (1 char length allowed only)\n * @return Padded string or the same string if it is already of given length (or larger).\n */\nfunction padStart(value, length, fillChar = \" \") {\n    return padInternal(value, length, \"start\", fillChar);\n}\n/**\n * Pad given value with given fillChar from the end (default is an empty space)\n * @param value Value to pad\n * @param length The length the string must be\n * @param fillChar The padding char (1 char length allowed only)\n * @return Padded string or the same string if it is already of given length (or larger).\n */\nfunction padEnd(value, length, fillChar = \" \") {\n    return padInternal(value, length, \"end\", fillChar);\n}\n/**\n * Returns the max length of a string value in given array\n * @param arr Array to check\n * @return Max length, 0 if array is empty\n */\nfunction maxLengthStringValueInArray(arr) {\n    return arr\n        .map(v => v.length)\n        .reduce((previous, current) => {\n        if (current > previous) {\n            return current;\n        }\n        return previous;\n    }, 0);\n}\nfunction padInternal(value, length, padType, fillChar = \" \") {\n    if (length <= value.length) {\n        return value;\n    }\n    if (fillChar.length > 1) {\n        throw new Error(`Fill char must be one char exactly, it is: ${fillChar.length}`);\n    }\n    const charsNeeded = length - value.length;\n    let padding = \"\";\n    for (let i = 0; i < charsNeeded; i++) {\n        padding += fillChar;\n    }\n    if (padType === \"start\") {\n        return padding + value;\n    }\n    return value + padding;\n}\n\n/**\n * Default argument formatter function, used by the library, see {@link ArgumentFormatterType}.\n * Can be used by an end user as well if needed.\n * @param arg The argument to format\n * @returns argument stringified to string (JSON.stringify), if arg is undefined returns \"undefined\" (without quotes).\n */\nfunction formatArgument(arg) {\n    if (arg === undefined) {\n        return \"undefined\";\n    }\n    return JSON.stringify(arg);\n}\n/**\n * Default date formatter function, used by the library, see {@link DateFormatterType}.\n * Can be used by an end user as well if needed.\n * @param millisSinceEpoch Milliseconds since epoch\n * @returns The date in format: yyyy-MM-dd HH:mm:ss,SSS (example: 2021-02-26 09:06:28,123)\n */\nfunction formatDate(millisSinceEpoch) {\n    const date = new Date(millisSinceEpoch);\n    const year = date.getFullYear();\n    const month = padStart((date.getMonth() + 1).toString(), 2, \"0\");\n    const day = padStart(date.getDate().toString(), 2, \"0\");\n    const hours = padStart(date.getHours().toString(), 2, \"0\");\n    const minutes = padStart(date.getMinutes().toString(), 2, \"0\");\n    const seconds = padStart(date.getSeconds().toString(), 2, \"0\");\n    const millis = padStart(date.getMilliseconds().toString(), 3, \"0\");\n    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds},${millis}`;\n}\n\n/* tslint:disable:no-console */\n/**\n * Default standard LogChannel which logs to console.\n */\nclass ConsoleLogChannel {\n    constructor() {\n        this.type = \"LogChannel\";\n    }\n    write(msg) {\n        if (console && console.log) {\n            console.log(msg.message + (msg.error ? `\\n${msg.error}` : \"\"));\n        }\n    }\n}\n\n/* tslint:disable:no-namespace */\n/**\n * Provides access to various default channels provided by typescript logging.\n */\nvar DefaultChannels;\n(function (DefaultChannels) {\n    /**\n     * Create a new standard LogChannel that logs to the console.\n     */\n    function createConsoleChannel() {\n        return new ConsoleLogChannel();\n    }\n    DefaultChannels.createConsoleChannel = createConsoleChannel;\n})(DefaultChannels || (DefaultChannels = {}));\n\n/**\n * Implementation for {@link LogProvider}\n */\nclass LogProviderImpl {\n    constructor(name, settings) {\n        this._log = getInternalLogger(\"core.impl.LogProviderImpl\");\n        this._name = name;\n        this._settings = settings;\n        this._loggers = new EnhancedMap();\n        this._idToKeyMap = new EnhancedMap();\n        this._globalRuntimeSettings = { level: settings.level, channel: settings.channel };\n        this._nextLoggerId = 1;\n        this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);\n    }\n    get runtimeSettings() {\n        return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });\n    }\n    getLogger(name) {\n        return this.getOrCreateLogger(name);\n    }\n    updateLoggerRuntime(log, settings) {\n        this._log.debug(() => `Updating logger ${log.id} runtime settings using: '${JSON.stringify(settings)}'`);\n        const key = this._idToKeyMap.get(log.id);\n        if (key === undefined) {\n            this._log.warn(() => `Cannot update logger with id: ${log.id}, it was not found.`);\n            return false;\n        }\n        this._loggers.computeIfPresent(key, (currentKey, currentValue) => {\n            currentValue.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(currentValue.runtimeSettings, settings);\n            return currentValue;\n        });\n        return true;\n    }\n    updateRuntimeSettings(settings) {\n        this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(settings)}'`);\n        this._globalRuntimeSettings = {\n            /*\n             * Undefined check is necessary, as level is a number (and LogLevel.Trace = 0), a ternary check otherwise results in the annoying \"truthy/falsy\"\n             * behavior of javascript where 0 is seen as false.\n             */\n            level: settings.level !== undefined ? settings.level : this._globalRuntimeSettings.level,\n            channel: settings.channel !== undefined ? settings.channel : this._globalRuntimeSettings.channel,\n        };\n        this._loggers.forEach(logger => logger.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(logger.runtimeSettings, settings));\n    }\n    /**\n     * Removes all state and loggers, it reverts back to as it was after initial construction.\n     */\n    clear() {\n        this._loggers.clear();\n        this._idToKeyMap.clear();\n        this._globalRuntimeSettings = Object.assign({}, this._settings);\n        this._nextLoggerId = 1;\n    }\n    getOrCreateLogger(name) {\n        const key = LogProviderImpl.createKey(name);\n        const logger = this._loggers.computeIfAbsent(key, () => {\n            const runtime = {\n                level: this._globalRuntimeSettings.level,\n                channel: this._globalRuntimeSettings.channel,\n                id: this.nextLoggerId(),\n                name,\n                argumentFormatter: this._settings.argumentFormatter,\n                dateFormatter: this._settings.dateFormatter,\n            };\n            return new CoreLoggerImpl(runtime);\n        });\n        this._idToKeyMap.computeIfAbsent(logger.id, () => key);\n        return logger;\n    }\n    nextLoggerId() {\n        const result = this._name + \"_\" + this._nextLoggerId;\n        this._nextLoggerId++;\n        return result;\n    }\n    static mergeRuntimeSettingsIntoLogRuntime(currentSettings, settings) {\n        return Object.assign(Object.assign({}, currentSettings), { \n            /*\n             * Undefined check is necessary, as level is a number (and LogLevel.Trace = 0), a ternary check otherwise results in the annoying \"truthy/falsy\"\n             * behavior of javascript where 0 is seen as false.\n             */\n            level: settings.level !== undefined ? settings.level : currentSettings.level, channel: settings.channel !== undefined ? settings.channel : currentSettings.channel });\n    }\n    static createKey(name) {\n        if (typeof name === \"string\") {\n            return name;\n        }\n        return name.join(\",\");\n    }\n}\n\n/**\n * Create a new LogProvider, this is for flavor usage only. End users should not\n * use this and instead use whatever the flavor offers to build some config and\n * get loggers from there.\n */\nfunction createLogProvider(name, settings) {\n    return new LogProviderImpl(name, settings);\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  EnhancedMap: EnhancedMap,\n  maxLengthStringValueInArray: maxLengthStringValueInArray,\n  padEnd: padEnd,\n  padStart: padStart\n});\n\n/**\n * LogChannel that pushes log messages to a buffer.\n */\nclass ArrayLogChannel {\n    constructor() {\n        this._buffer = [];\n        this.type = \"LogChannel\";\n    }\n    write(msg) {\n        this._buffer.push(msg);\n    }\n    get logMessages() {\n        return this._buffer;\n    }\n    get messages() {\n        return this._buffer.map(msg => msg.message);\n    }\n}\n/**\n * RawLogChannel that pushes raw log messages to a buffer.\n */\nclass ArrayRawLogChannel {\n    constructor() {\n        this._buffer = [];\n        this.type = \"RawLogChannel\";\n    }\n    write(msg, _) {\n        this._buffer.push(msg);\n    }\n    get messages() {\n        return this._buffer.map(m => m.message);\n    }\n    get errors() {\n        return this._buffer.map(m => m.exception);\n    }\n    get size() {\n        return this._buffer.length;\n    }\n    get rawMessages() {\n        return this._buffer;\n    }\n    clear() {\n        this._buffer = [];\n    }\n}\n/**\n * Test class to help test the log control.\n */\nclass TestControlMessage {\n    constructor() {\n        this._messages = [];\n        this.write = this.write.bind(this);\n    }\n    get messages() {\n        return this._messages;\n    }\n    write(msg) {\n        this._messages.push(msg);\n    }\n    clear() {\n        this._messages = [];\n    }\n}\n\nvar TestClasses = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ArrayLogChannel: ArrayLogChannel,\n  ArrayRawLogChannel: ArrayRawLogChannel,\n  TestControlMessage: TestControlMessage\n});\n\nexport { InternalLogger as $internal, TestClasses as $test, DefaultChannels, LogLevel, createLogProvider, formatArgument, formatDate, index as util };\n//# sourceMappingURL=typescript-logging.esm.js.map\n","/**\n * Extends Map and adds a few convenient functions.\n */\nclass EnhancedMap extends Map {\n    /**\n     * If key has a mapping already returns the currently associated value. If\n     * there is no mapping, calls the computer which must return a value V.\n     * The value is then stored for given key and returned.\n     * @param key Key\n     * @param computer Computer which is called only if key has no mapping yet.\n     * @return Existing value if the key already existed, or the newly computed value.\n     */\n    computeIfAbsent(key, computer) {\n        if (this.has(key)) {\n            return this.get(key);\n        }\n        const newValue = computer(key);\n        this.set(key, newValue);\n        return newValue;\n    }\n    /**\n     * If the key exists already calls given computer, if the key does not exist\n     * this method does nothing.\n     *\n     * The computer is called with current key and current value associated. The\n     * computer can return a (new) value V or undefined. When undefined is returned\n     * the key is removed from this map, when a V is returned the key is updated\n     * with the new value V.\n     * @param key Key\n     * @param computer Computer which is called only if the key has a mapping already\n     * @return Undefined if the key has no mapping, otherwise the value returned from computer\n     */\n    computeIfPresent(key, computer) {\n        const currentValue = this.get(key);\n        if (currentValue === undefined) {\n            return undefined;\n        }\n        const newValue = computer(key, currentValue);\n        if (newValue !== undefined) {\n            this.set(key, newValue);\n        }\n        else {\n            this.delete(key);\n        }\n        return newValue;\n    }\n    /**\n     * Computes a value for given key, the computer can return a value V (in which case the map\n     * will set the value for given key), if it returns undefined the mapping for key K will be\n     * removed.\n     * @param key Key to compute\n     * @param computer Computer which is called, note that the currentValue argument contains the existing\n     *                 value or is undefined when no mapping exists for the key.\n     * @return The newly computed value\n     */\n    compute(key, computer) {\n        const currentValue = this.get(key);\n        const newValue = computer(key, currentValue);\n        if (newValue) {\n            this.set(key, newValue);\n        }\n        else {\n            this.delete(key);\n        }\n        return newValue;\n    }\n}\n\n/**\n * Internal log level (note: do NOT use LogLevel, or we get circular loading issues!)\n */\nvar InternalLogLevel;\n(function (InternalLogLevel) {\n    InternalLogLevel[InternalLogLevel[\"Trace\"] = 0] = \"Trace\";\n    InternalLogLevel[InternalLogLevel[\"Debug\"] = 1] = \"Debug\";\n    InternalLogLevel[InternalLogLevel[\"Info\"] = 2] = \"Info\";\n    InternalLogLevel[InternalLogLevel[\"Warn\"] = 3] = \"Warn\";\n    InternalLogLevel[InternalLogLevel[\"Error\"] = 4] = \"Error\";\n})(InternalLogLevel || (InternalLogLevel = {}));\n/**\n * Internal logger, this is NOT for end users. Instead this is used to enable logging for typescript-logging itself in case of problems.\n *\n * @param name Name of logger\n */\nfunction getInternalLogger(name) {\n    return provider.getLogger(name);\n}\n/**\n * Can be used to change the *internal* logging of the library.\n * Has no effect on end user logging.\n *\n * As such should normally not be used by end users.\n */\nconst INTERNAL_LOGGING_SETTINGS = {\n    /**\n     * Changes the log level for the internal logging (for all new and existing loggers)\n     * @param level New log level\n     */\n    setInternalLogLevel: (level) => provider.changeLogLevel(level),\n    /**\n     * Changes where messages are written to for all new and existing loggers),\n     * by default they are written to the console.\n     * @param fnOutput Function to write messages to\n     */\n    setOutput: (fnOutput) => provider.changeOutput(fnOutput),\n    /**\n     * Resets the log level and output back to defaults (level to error and writing to console)\n     * for all new and existing loggers.\n     */\n    reset: () => provider.reset(),\n};\nclass InternalLoggerImpl {\n    constructor(name, level, fnOutput) {\n        this._name = name;\n        this._level = level;\n        this._fnOutput = fnOutput;\n    }\n    trace(msg) {\n        this.log(InternalLogLevel.Trace, msg);\n    }\n    debug(msg) {\n        this.log(InternalLogLevel.Debug, msg);\n    }\n    error(msg, error) {\n        this.log(InternalLogLevel.Error, msg, error);\n    }\n    info(msg) {\n        this.log(InternalLogLevel.Info, msg);\n    }\n    warn(msg, error) {\n        this.log(InternalLogLevel.Warn, msg, error);\n    }\n    setLevel(level) {\n        this._level = level;\n    }\n    setOutput(fnOutput) {\n        this._fnOutput = fnOutput;\n    }\n    log(level, msg, error) {\n        if (this._level > level) {\n            return;\n        }\n        // tslint:disable-next-line:no-console\n        this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${msg()}${error ? \"\\n\" + error.stack : \"\"}`);\n    }\n}\nclass InternalProviderImpl {\n    constructor() {\n        this._loggers = new EnhancedMap();\n        this._logLevel = InternalLogLevel.Error;\n        this._fnOutput = InternalProviderImpl.logConsole;\n    }\n    getLogger(name) {\n        return this._loggers.computeIfAbsent(name, key => new InternalLoggerImpl(key, this._logLevel, this._fnOutput));\n    }\n    changeLogLevel(level) {\n        this._logLevel = level;\n        this._loggers.forEach(logger => logger.setLevel(level));\n    }\n    changeOutput(_fnOutput) {\n        this._fnOutput = _fnOutput;\n        this._loggers.forEach(logger => logger.setOutput(this._fnOutput));\n    }\n    reset() {\n        this.changeLogLevel(InternalLogLevel.Error);\n        this._fnOutput = InternalProviderImpl.logConsole;\n        this._loggers.forEach(logger => logger.setOutput(this._fnOutput));\n    }\n    static logConsole(msg) {\n        // tslint:disable-next-line:no-console\n        if (console && console.log) {\n            // tslint:disable-next-line:no-console\n            console.log(msg);\n        }\n    }\n}\nconst provider = new InternalProviderImpl();\n\nvar InternalLogger = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS,\n  get InternalLogLevel () { return InternalLogLevel; },\n  getInternalLogger: getInternalLogger\n});\n\n/**\n * Log level for a logger.\n */\nvar LogLevel;\n(function (LogLevel) {\n    // Do not change values/order. Logging a message relies on this.\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 3] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n    LogLevel[LogLevel[\"Fatal\"] = 5] = \"Fatal\";\n    LogLevel[LogLevel[\"Off\"] = 6] = \"Off\";\n})(LogLevel || (LogLevel = {}));\n/* tslint:disable:no-namespace */\n(function (LogLevel) {\n    /**\n     * Convert given value to LogLevel, if not matching returns undefined.\n     * @param val Value to convert\n     */\n    function toLogLevel(val) {\n        switch (val.toLowerCase()) {\n            case \"trace\":\n                return LogLevel.Trace;\n            case \"debug\":\n                return LogLevel.Debug;\n            case \"info\":\n                return LogLevel.Info;\n            case \"warn\":\n                return LogLevel.Warn;\n            case \"error\":\n                return LogLevel.Error;\n            case \"fatal\":\n                return LogLevel.Fatal;\n            case \"off\":\n                return LogLevel.Off;\n            default:\n                return undefined;\n        }\n    }\n    LogLevel.toLogLevel = toLogLevel;\n})(LogLevel || (LogLevel = {}));\n/* tslint:disable:enable-namespace */\n\n/**\n * Standard logger implementation that provides the basis for all loggers.\n */\nclass CoreLoggerImpl {\n    constructor(runtime) {\n        this._runtime = runtime;\n    }\n    get id() {\n        return this._runtime.id;\n    }\n    get logLevel() {\n        return this._runtime.level;\n    }\n    get runtimeSettings() {\n        /* Return it as new literal, we don't want people to play with our internal state */\n        return Object.assign({}, this._runtime);\n    }\n    set runtimeSettings(runtime) {\n        this._runtime = runtime;\n    }\n    trace(message, ...args) {\n        this.logMessage(LogLevel.Trace, message, args);\n    }\n    debug(message, ...args) {\n        this.logMessage(LogLevel.Debug, message, args);\n    }\n    info(message, ...args) {\n        this.logMessage(LogLevel.Info, message, args);\n    }\n    warn(message, ...args) {\n        this.logMessage(LogLevel.Warn, message, args);\n    }\n    error(message, ...args) {\n        this.logMessage(LogLevel.Error, message, args);\n    }\n    fatal(message, ...args) {\n        this.logMessage(LogLevel.Fatal, message, args);\n    }\n    logMessage(level, logMessageType, args) {\n        if (this._runtime.level > level) {\n            return;\n        }\n        const nowMillis = Date.now();\n        const message = typeof logMessageType === \"string\" ? logMessageType : logMessageType();\n        const errorAndArgs = CoreLoggerImpl.getErrorAndArgs(args);\n        /*\n         * Deal with raw message here.\n         */\n        switch (this._runtime.channel.type) {\n            case \"RawLogChannel\":\n                this._runtime.channel.write({\n                    message,\n                    exception: errorAndArgs.error,\n                    args: errorAndArgs.args,\n                    timeInMillis: nowMillis,\n                    level,\n                    logNames: this._runtime.name,\n                }, this._runtime.argumentFormatter);\n                return;\n            case \"LogChannel\":\n                this._runtime.channel.write(this.createLogMessage(message, level, errorAndArgs, nowMillis));\n                break;\n        }\n    }\n    formatArgValue(value) {\n        try {\n            return this._runtime.argumentFormatter(value);\n        }\n        catch (e) {\n            // We don't really care what failed, except that the convert function failed.\n            return `>>ARG CONVERT FAILED: '${value !== undefined ? value.toString() : \"undefined\"}'<<`;\n        }\n    }\n    createLogMessage(message, level, errorAndArgs, nowMillis) {\n        let errorResult;\n        const error = errorAndArgs.error;\n        const args = errorAndArgs.args;\n        if (error) {\n            errorResult = `${error.name}: ${error.message}`;\n            if (error.stack) {\n                errorResult += `@\\n${error.stack}`;\n            }\n        }\n        /*\n         * We need to add the date, and log names (in front of the now formatted message).\n         * Finally we also need to format any additional arguments and append after the message.\n         */\n        const dateFormatted = this._runtime.dateFormatter(nowMillis);\n        let levelAsStr = LogLevel[level].toUpperCase();\n        if (levelAsStr.length < 5) {\n            levelAsStr += \" \";\n        }\n        const names = typeof this._runtime.name === \"string\" ? this._runtime.name : this._runtime.name.join(\", \");\n        const argsFormatted = typeof args !== \"undefined\" && args.length > 0 ? (\" [\" + (args.map(arg => this.formatArgValue(arg))).join(\", \") + \"]\") : \"\";\n        const completedMessage = dateFormatted + \" \" + levelAsStr + \" [\" + names + \"] \" + message + argsFormatted;\n        return {\n            message: completedMessage,\n            error: errorResult,\n        };\n    }\n    static getErrorAndArgs(args) {\n        /*\n          The args are optional, but the first entry may be an Error or a function to an Error, or finally be a function to extra arguments.\n          The last is only true, if the length of args === 1, otherwise we expect args starting at pos 1 and further to be just that - args.\n         */\n        if (args.length === 0) {\n            return {};\n        }\n        let error;\n        let actualArgs;\n        const value0 = args[0];\n        /* If the first argument is an Error, we can stop straight away, the rest are additional arguments then if any */\n        if (value0 instanceof Error) {\n            error = value0;\n            actualArgs = args.length > 1 ? args.slice(1) : undefined;\n            return { error, args: actualArgs };\n        }\n        /* If the first argument is a function, it means either it will return the Error, or if the array length === 1 a function, returning the arguments */\n        if (typeof value0 === \"function\") {\n            const errorOrArgs = value0();\n            if (errorOrArgs instanceof Error) {\n                error = errorOrArgs;\n                actualArgs = args.length > 1 ? args.slice(1) : undefined;\n                return { error, args: actualArgs };\n            }\n            if (args.length === 1) {\n                /* The first argument was a function, we assume it returned the extra argument(s) */\n                if (Array.isArray(errorOrArgs)) {\n                    return { args: errorOrArgs.length > 0 ? errorOrArgs : undefined };\n                }\n                else {\n                    /* No idea what was returned we just assume a single value */\n                    return { args: errorOrArgs };\n                }\n            }\n            else {\n                /*\n                  This is a weird situation but there's no way to avoid it, the first argument was a function but did not return an Error and the args are > 1,\n                  so just add the args returned, as well as any remaining.\n                */\n                if (Array.isArray(errorOrArgs)) {\n                    return { args: [...errorOrArgs, ...args.slice(1)] };\n                }\n                return { args: [errorOrArgs, ...args.slice(1)] };\n            }\n        }\n        /* All args are ordinary arguments, or at least the first arg was not an Error or a Function, so we add all as args */\n        return { args };\n    }\n}\n\n/**\n * Pad given value with given fillChar from the beginning (default is an empty space)\n * @param value Value to pad\n * @param length The length the string must be\n * @param fillChar The padding char (1 char length allowed only)\n * @return Padded string or the same string if it is already of given length (or larger).\n */\nfunction padStart(value, length, fillChar = \" \") {\n    return padInternal(value, length, \"start\", fillChar);\n}\n/**\n * Pad given value with given fillChar from the end (default is an empty space)\n * @param value Value to pad\n * @param length The length the string must be\n * @param fillChar The padding char (1 char length allowed only)\n * @return Padded string or the same string if it is already of given length (or larger).\n */\nfunction padEnd(value, length, fillChar = \" \") {\n    return padInternal(value, length, \"end\", fillChar);\n}\n/**\n * Returns the max length of a string value in given array\n * @param arr Array to check\n * @return Max length, 0 if array is empty\n */\nfunction maxLengthStringValueInArray(arr) {\n    return arr\n        .map(v => v.length)\n        .reduce((previous, current) => {\n        if (current > previous) {\n            return current;\n        }\n        return previous;\n    }, 0);\n}\nfunction padInternal(value, length, padType, fillChar = \" \") {\n    if (length <= value.length) {\n        return value;\n    }\n    if (fillChar.length > 1) {\n        throw new Error(`Fill char must be one char exactly, it is: ${fillChar.length}`);\n    }\n    const charsNeeded = length - value.length;\n    let padding = \"\";\n    for (let i = 0; i < charsNeeded; i++) {\n        padding += fillChar;\n    }\n    if (padType === \"start\") {\n        return padding + value;\n    }\n    return value + padding;\n}\n\n/**\n * Default argument formatter function, used by the library, see {@link ArgumentFormatterType}.\n * Can be used by an end user as well if needed.\n * @param arg The argument to format\n * @returns argument stringified to string (JSON.stringify), if arg is undefined returns \"undefined\" (without quotes).\n */\nfunction formatArgument(arg) {\n    if (arg === undefined) {\n        return \"undefined\";\n    }\n    return JSON.stringify(arg);\n}\n/**\n * Default date formatter function, used by the library, see {@link DateFormatterType}.\n * Can be used by an end user as well if needed.\n * @param millisSinceEpoch Milliseconds since epoch\n * @returns The date in format: yyyy-MM-dd HH:mm:ss,SSS (example: 2021-02-26 09:06:28,123)\n */\nfunction formatDate(millisSinceEpoch) {\n    const date = new Date(millisSinceEpoch);\n    const year = date.getFullYear();\n    const month = padStart((date.getMonth() + 1).toString(), 2, \"0\");\n    const day = padStart(date.getDate().toString(), 2, \"0\");\n    const hours = padStart(date.getHours().toString(), 2, \"0\");\n    const minutes = padStart(date.getMinutes().toString(), 2, \"0\");\n    const seconds = padStart(date.getSeconds().toString(), 2, \"0\");\n    const millis = padStart(date.getMilliseconds().toString(), 3, \"0\");\n    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds},${millis}`;\n}\n\n/* tslint:disable:no-console */\n/**\n * Default standard LogChannel which logs to console.\n */\nclass ConsoleLogChannel {\n    constructor() {\n        this.type = \"LogChannel\";\n    }\n    write(msg) {\n        if (console && console.log) {\n            console.log(msg.message + (msg.error ? `\\n${msg.error}` : \"\"));\n        }\n    }\n}\n\n/* tslint:disable:no-namespace */\n/**\n * Provides access to various default channels provided by typescript logging.\n */\nvar DefaultChannels;\n(function (DefaultChannels) {\n    /**\n     * Create a new standard LogChannel that logs to the console.\n     */\n    function createConsoleChannel() {\n        return new ConsoleLogChannel();\n    }\n    DefaultChannels.createConsoleChannel = createConsoleChannel;\n})(DefaultChannels || (DefaultChannels = {}));\n\n/**\n * Implementation for {@link LogProvider}\n */\nclass LogProviderImpl {\n    constructor(name, settings) {\n        this._log = getInternalLogger(\"core.impl.LogProviderImpl\");\n        this._name = name;\n        this._settings = settings;\n        this._loggers = new EnhancedMap();\n        this._idToKeyMap = new EnhancedMap();\n        this._globalRuntimeSettings = { level: settings.level, channel: settings.channel };\n        this._nextLoggerId = 1;\n        this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);\n    }\n    get runtimeSettings() {\n        return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });\n    }\n    getLogger(name) {\n        return this.getOrCreateLogger(name);\n    }\n    updateLoggerRuntime(log, settings) {\n        this._log.debug(() => `Updating logger ${log.id} runtime settings using: '${JSON.stringify(settings)}'`);\n        const key = this._idToKeyMap.get(log.id);\n        if (key === undefined) {\n            this._log.warn(() => `Cannot update logger with id: ${log.id}, it was not found.`);\n            return false;\n        }\n        this._loggers.computeIfPresent(key, (currentKey, currentValue) => {\n            currentValue.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(currentValue.runtimeSettings, settings);\n            return currentValue;\n        });\n        return true;\n    }\n    updateRuntimeSettings(settings) {\n        this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(settings)}'`);\n        this._globalRuntimeSettings = {\n            /*\n             * Undefined check is necessary, as level is a number (and LogLevel.Trace = 0), a ternary check otherwise results in the annoying \"truthy/falsy\"\n             * behavior of javascript where 0 is seen as false.\n             */\n            level: settings.level !== undefined ? settings.level : this._globalRuntimeSettings.level,\n            channel: settings.channel !== undefined ? settings.channel : this._globalRuntimeSettings.channel,\n        };\n        this._loggers.forEach(logger => logger.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(logger.runtimeSettings, settings));\n    }\n    /**\n     * Removes all state and loggers, it reverts back to as it was after initial construction.\n     */\n    clear() {\n        this._loggers.clear();\n        this._idToKeyMap.clear();\n        this._globalRuntimeSettings = Object.assign({}, this._settings);\n        this._nextLoggerId = 1;\n    }\n    getOrCreateLogger(name) {\n        const key = LogProviderImpl.createKey(name);\n        const logger = this._loggers.computeIfAbsent(key, () => {\n            const runtime = {\n                level: this._globalRuntimeSettings.level,\n                channel: this._globalRuntimeSettings.channel,\n                id: this.nextLoggerId(),\n                name,\n                argumentFormatter: this._settings.argumentFormatter,\n                dateFormatter: this._settings.dateFormatter,\n            };\n            return new CoreLoggerImpl(runtime);\n        });\n        this._idToKeyMap.computeIfAbsent(logger.id, () => key);\n        return logger;\n    }\n    nextLoggerId() {\n        const result = this._name + \"_\" + this._nextLoggerId;\n        this._nextLoggerId++;\n        return result;\n    }\n    static mergeRuntimeSettingsIntoLogRuntime(currentSettings, settings) {\n        return Object.assign(Object.assign({}, currentSettings), { \n            /*\n             * Undefined check is necessary, as level is a number (and LogLevel.Trace = 0), a ternary check otherwise results in the annoying \"truthy/falsy\"\n             * behavior of javascript where 0 is seen as false.\n             */\n            level: settings.level !== undefined ? settings.level : currentSettings.level, channel: settings.channel !== undefined ? settings.channel : currentSettings.channel });\n    }\n    static createKey(name) {\n        if (typeof name === \"string\") {\n            return name;\n        }\n        return name.join(\",\");\n    }\n}\n\n/**\n * Create a new LogProvider, this is for flavor usage only. End users should not\n * use this and instead use whatever the flavor offers to build some config and\n * get loggers from there.\n */\nfunction createLogProvider(name, settings) {\n    return new LogProviderImpl(name, settings);\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  EnhancedMap: EnhancedMap,\n  maxLengthStringValueInArray: maxLengthStringValueInArray,\n  padEnd: padEnd,\n  padStart: padStart\n});\n\nfunction log4TSGroupConfigDebug(config) {\n    return `Log4TSGroupConfig=level: ${LogLevel[config.level].toString()}, expression: ${config.expression.toString()}, (omitted functions/channel)`;\n}\nfunction log4TSConfigDebug(config) {\n    const groupLog = config.groups.map(g => log4TSGroupConfigDebug(g)).join(\", \");\n    return `Log4TSGroupConfig=level: ${LogLevel[config.level].toString()}, groups: ${groupLog}, (omitted functions/channel)`;\n}\n\n/**\n * Implementation class for Log4TSProvider.\n */\nclass Log4TSProviderImpl {\n    constructor(name, defaultConfig, groupConfigs) {\n        this._log = InternalLogger.getInternalLogger(\"log4ts.impl.Log4TSProviderImpl\");\n        this._name = name;\n        /* The default config, used as fallback if a logger does not match any group */\n        this._defaultConfig = [Object.assign(Object.assign({}, defaultConfig), { identifier: defaultConfig.identifier }), createLogProvider(\"log4ts_\" + name + \"_\" + defaultConfig.identifier, defaultConfig)];\n        /* Create various providers for the different groups so each will have the correct config */\n        this._logProviders = new Map(groupConfigs.map(config => {\n            const updatedConfig = Object.assign({}, config);\n            const provider = createLogProvider(\"log4ts_\" + name + \"_\" + config.identifier, config);\n            return [config.identifier, { groupConfig: updatedConfig, provider }];\n        }));\n        this._log.trace(() => {\n            const groupProvLog = [...this._logProviders.values()].map(e => log4TSGroupConfigDebug(e.groupConfig)).join(\", \");\n            return `Creating Log4TSProviderImpl '${this._name}', defaultConfig: ${log4TSGroupConfigDebug(this._defaultConfig[0])}, groupConfigs: ${groupProvLog}`;\n        });\n    }\n    get name() {\n        return this._name;\n    }\n    get config() {\n        /* We create the settings to return anew, to prevent people change the content in any way */\n        return Object.assign({}, this._defaultConfig[0]);\n    }\n    get groupConfigs() {\n        /* We create the settings to return anew, to prevent people change the content in any way */\n        return [...this._logProviders.values()].map(v => (Object.assign({}, v.groupConfig)));\n    }\n    getLogger(name) {\n        /* Walk them in insertion order, that is the order we must match for */\n        for (const value of this._logProviders.values()) {\n            if (value.groupConfig.expression.test(name)) {\n                return value.provider.getLogger(name);\n            }\n        }\n        /* Fallback to the default we don't care if it matches in this case */\n        return this._defaultConfig[1].getLogger(name);\n    }\n    updateRuntimeSettingsGroup(identifier, config) {\n        const value = this._logProviders.get(identifier);\n        if (value === undefined) {\n            throw new Error(`Cannot update group with identifier '${identifier}', it does not exist.`);\n        }\n        this._log.debug(() => `Will update ${log4TSGroupConfigDebug(value.groupConfig)}, associated LogProvider '${value.provider}' - applying runtime change: ${JSON.stringify(config)}.`);\n        Log4TSProviderImpl.updateLog4TGroupConfig(value.groupConfig, value.provider, config);\n    }\n    updateRuntimeSettings(settings) {\n        this._log.debug(() => `Will update settings for all groups and existing loggers - will apply runtime change: ${JSON.stringify(settings)}.`);\n        this._logProviders.forEach(value => {\n            const groupConfig = value.groupConfig;\n            const provider = value.provider;\n            this._log.debug(() => `Will update ${log4TSGroupConfigDebug(groupConfig)}, associated LogProvider '${provider}' - applying runtime change: ${JSON.stringify(settings)}.`);\n            Log4TSProviderImpl.updateLog4TGroupConfig(groupConfig, provider, settings);\n        });\n    }\n    static updateLog4TGroupConfig(cfg, provider, runtimeSettings) {\n        if (runtimeSettings.level) {\n            cfg.level = runtimeSettings.level;\n        }\n        if (runtimeSettings.channel) {\n            cfg.channel = runtimeSettings.channel;\n        }\n        provider.updateRuntimeSettings(runtimeSettings);\n    }\n}\n\n/**\n * Implementation for Log4TSControlProvider.\n */\nclass Log4TSControlProviderImpl {\n    constructor(provider, messageChannel) {\n        this._provider = provider;\n        this._messageChannel = messageChannel;\n        // Identifier is guaranteed to be set internally.\n        this._originalLogLevels = Log4TSControlProviderImpl.loadCurrentGroupLogLevels(provider);\n    }\n    get name() {\n        return this._provider.name;\n    }\n    showSettings() {\n        let result = `Available group configs (Log4TSProvider '${this._provider.name}'):\\n`;\n        /*\n         * Make the identifier always set, similar on how to update a group.\n         */\n        const groupConfigs = this._provider.groupConfigs.map(cfg => ({\n            level: LogLevel[cfg.level],\n            channelDescription: cfg.channel.toString ? cfg.channel.toString() : JSON.stringify(cfg.channel),\n            identifier: cfg.identifier,\n        }));\n        const maxWidthIndex = groupConfigs.length.toString().length;\n        const maxWidthIdentifier = index.maxLengthStringValueInArray(groupConfigs.map(cfg => cfg.identifier));\n        const maxWidthLevel = 5;\n        /*\n          We create this kind of output:\n    \n          Available group configs (Log4TSProvider 'test'):\n            [0, /model.+/:             level=Error]\n            [1, /advanced.+/:          level=Warn ]\n            [2, my awesome identifier: level=Error]\n            [3, /blaat.blaat.+/:       level=Error]\n         */\n        const providerLines = groupConfigs\n            .map((cfg, index$1) => `  [${index.padStart(index$1.toString(), maxWidthIndex)}, ${index.padEnd(cfg.identifier, maxWidthIdentifier)} (level=${index.padEnd(cfg.level, maxWidthLevel)})]`)\n            .join(\"\\n\");\n        result += providerLines + \"\\n\";\n        this._messageChannel(result);\n    }\n    update(level, groupId) {\n        const newLevel = LogLevel.toLogLevel(level);\n        if (newLevel === undefined) {\n            throw new Error(`Cannot update log provider, log level '${level}' is invalid.`);\n        }\n        const settings = {\n            level: newLevel,\n        };\n        /*\n         * Update all groups.\n         */\n        if (groupId === undefined) {\n            this._provider.updateRuntimeSettings(settings);\n            this._messageChannel(\"Updated all group configs successfully.\");\n            return;\n        }\n        /*\n         * Find the group by index and update it using its identifier.\n         */\n        if (typeof groupId === \"number\") {\n            const groups = this._provider.groupConfigs;\n            if (groupId < 0 || groupId >= groups.length) {\n                throw new Error(`Group config with index '${groupId}' does not exist (outside of range).`);\n            }\n            const expectedGroup = groups[groupId];\n            this._provider.updateRuntimeSettingsGroup(expectedGroup.identifier, settings);\n            this._messageChannel(`Updated group config with index '${groupId}' successfully.`);\n            return;\n        }\n        /* Update the group by its identifier directly */\n        this._provider.updateRuntimeSettingsGroup(groupId, settings);\n        this._messageChannel(`Updated group config with id '${groupId}' successfully.`);\n    }\n    reset() {\n        this._originalLogLevels.forEach((value, key) => {\n            this._provider.updateRuntimeSettingsGroup(key, { level: value });\n        });\n        this._messageChannel(\"Successfully reset log levels back to original state (from when this Log4TSControlProvider was created).\");\n    }\n    save() {\n        if (!localStorage) {\n            this._messageChannel(\"Cannot save state, localStorage is not available.\");\n            return;\n        }\n        const data = {\n            name: this._provider.name,\n            groups: this._provider.groupConfigs.map(cfg => ({ identifier: cfg.identifier, level: LogLevel[cfg.level] })),\n        };\n        localStorage.setItem(this.createKey(), JSON.stringify(data));\n        this._messageChannel(`Successfully saved state for Log4TSControlProvider '${this._provider.name}'.`);\n    }\n    restore(logRestoreFailures) {\n        const finalLogRestoreFailures = logRestoreFailures !== undefined ? logRestoreFailures : true;\n        if (!localStorage) {\n            if (finalLogRestoreFailures) {\n                this._messageChannel(`Will not attempt to restore state for Log4TSControlProvider '${this._provider.name}', localStorage is not available.`);\n            }\n            return;\n        }\n        const key = this.createKey();\n        const value = localStorage.getItem(key);\n        if (value === null) {\n            if (finalLogRestoreFailures) {\n                this._messageChannel(`Cannot restore state for Log4TSControlProvider '${this._provider.name}', no data available.`);\n            }\n            return;\n        }\n        try {\n            const savedData = JSON.parse(value);\n            if (this._provider.name !== savedData.name) {\n                if (finalLogRestoreFailures) {\n                    this._messageChannel(`Cannot restore state for Log4TSControlProvider '${this._provider.name}', data is not for provider - found name '${savedData.name}'.`);\n                }\n                return;\n            }\n            this.restoreGroups(savedData, finalLogRestoreFailures);\n            this._originalLogLevels = Log4TSControlProviderImpl.loadCurrentGroupLogLevels(this._provider);\n        }\n        catch (e) {\n            localStorage.removeItem(key);\n            this._messageChannel(`Cannot restore state for Log4TSControlProvider '${this._provider.name}', data is not valid. Invalid data removed from localStorage.`);\n        }\n    }\n    help() {\n        const msg = `You can use the following commands (Log4TSProvider ${this._provider.name}):\\n` +\n            \"  showSettings()\\n\" +\n            \"    Shows the current configuration settings.\\n\" +\n            \"  update(logLevel: Log4TSControlProviderLogLevel, groupId?: number | string)\\n\" +\n            \"    Change the log level for one or all config groups.\\n\" +\n            \"      @param level   The log level to set - must be one of 'trace', 'debug', 'info', 'warn', 'error' or 'fatal'\\n\" +\n            \"      @param groupId Optional group config to update by either index or identifier, when omitted updates all groups.\\n\" +\n            \"                     Use showSettings() to find details about index and/or identifier.\\n\" +\n            \"  reset()\\n\" +\n            \"    Resets the log levels of the config groups back to when this control provider was created.\\n\" +\n            \"  save()\\n\" +\n            \"    Saves the current log levels for all config groups of this provider. Use restore() to load last saved state.\\n\" +\n            \"  restore()\\n\" +\n            \"    Restore stored saved state, if any. Log levels will be set according to saved state.\\n\" +\n            \"  help()\\n\" +\n            \"    Shows this help.\\n\";\n        this._messageChannel(msg);\n    }\n    restoreGroups(saveData, logCannotRestore) {\n        saveData.groups.forEach(group => {\n            try {\n                const newLevel = LogLevel.toLogLevel(group.level);\n                if (newLevel !== undefined) {\n                    this._provider.updateRuntimeSettingsGroup(group.identifier, { level: newLevel });\n                    this._messageChannel(`Log4TSControlProvider '${this._provider.name}' - restored log level of group '${group.identifier}' to '${LogLevel[newLevel]}'.`);\n                }\n                else {\n                    if (logCannotRestore) {\n                        this._messageChannel(`Log4TSControlProvider '${this._provider.name}' - failed to restore log level of group '${group.identifier}', invalid log level was specified.`);\n                    }\n                }\n            }\n            catch (e) {\n                if (logCannotRestore) {\n                    this._messageChannel(`Log4TSControlProvider '${this._provider.name}' - failed to restore log level of group '${group.identifier}'.`);\n                }\n            }\n        });\n    }\n    createKey() {\n        return `Log4TSProvider-${this._provider.name}`;\n    }\n    static loadCurrentGroupLogLevels(provider) {\n        return new Map(provider.groupConfigs.map(cfg => [cfg.identifier, cfg.level]));\n    }\n}\n\n/**\n * Provider for the Log4TS flavor, each provider is a unique instance that can be used to\n * get loggers from.\n */\nclass Log4TSProviderService {\n    constructor() {\n        this._log = InternalLogger.getInternalLogger(\"log4ts.impl.Log4TSProviderService\");\n        this._providers = new index.EnhancedMap();\n    }\n    createLogProvider(name, config) {\n        const result = this._providers.compute(name, (key, currentValue) => {\n            if (currentValue) {\n                throw new Error(`Log4TSProvider with name '${name}' already exists, cannot create another.`);\n            }\n            const mainConfig = mergeLog4TSConfigs(createDefaultLog4TSConfig(), config);\n            validateLog4TSConfig(mainConfig);\n            this._log.debug(() => `Creating new Log4TSProvider with name '${name}', using main config settings '${log4TSConfigDebug(mainConfig)}'.`);\n            const defaultExpression = new RegExp(\".+\");\n            const defaultGroupConfig = {\n                channel: mainConfig.channel,\n                level: mainConfig.level,\n                expression: defaultExpression,\n                dateFormatter: mainConfig.dateFormatter,\n                argumentFormatter: mainConfig.argumentFormatter,\n                identifier: defaultExpression.toString(),\n            };\n            return new Log4TSProviderImpl(key, defaultGroupConfig, mainConfig.groups);\n        });\n        // Cannot be undefined we do not allow it.\n        return result;\n    }\n    /**\n     * Clears all providers and configuration, the service reverts back to initial state.\n     */\n    clear() {\n        this._providers.clear();\n    }\n    getLog4TSControl(fnValue) {\n        const fnMessageChannel = fnValue ? fnValue : (value) => {\n            // tslint:disable-next-line:no-console\n            if (console && console.log) {\n                // tslint:disable-next-line:no-console\n                console.log(value);\n            }\n            else {\n                throw new Error(\"Cannot use console (it is not present), please specify a custom function to write to.\");\n            }\n        };\n        return {\n            help: () => fnMessageChannel(Log4TSProviderService.help()),\n            showSettings: () => fnMessageChannel(this.showSettings()),\n            getProvider: (id) => this.getLog4TSControlProviderByIdOrName(id, fnMessageChannel),\n        };\n    }\n    showSettings() {\n        let result = \"Available Log4TSProviders:\\n\";\n        const maxWidthIndex = this._providers.size.toString().length;\n        const maxWidthName = index.maxLengthStringValueInArray([...this._providers.keys()]);\n        const lines = [...this._providers.entries()].map((entry, index$1) => {\n            const name = entry[0];\n            /* [idx, name] */\n            return `  [${index.padStart(index$1.toString(), maxWidthIndex)}, ${index.padEnd(name, maxWidthName)}]`;\n        });\n        result += lines.join(\"\\n\") + (lines.length > 0 ? \"\\n\" : \"\");\n        return result;\n    }\n    getLog4TSControlProviderByIdOrName(id, messageChannel) {\n        if (typeof id === \"string\") {\n            const provider = this._providers.get(id);\n            if (provider === undefined) {\n                throw new Error(`Provider with name '${id}' does not exist.`);\n            }\n            return new Log4TSControlProviderImpl(provider, messageChannel);\n        }\n        const providers = [...this._providers.values()];\n        if (id < 0 || id >= providers.length) {\n            throw new Error(`Provider with index '${id}' does not exist (outside of range).`);\n        }\n        return new Log4TSControlProviderImpl(providers[id], messageChannel);\n    }\n    static help() {\n        return \"You can use the following commands:\\n\" +\n            \"  showSettings()\\n\" +\n            \"    Shows the current configuration settings.\\n\" +\n            \"  getProvider: (id: number | string): Log4TSControlProvider\\n\" +\n            \"    Get access to a Log4TSControlProvider to change log levels.\\n\" +\n            \"      @param id The id (use showSettings to see) or name of the provider\\n\" +\n            \"  help()\\n\" +\n            \"    Shows this help.\\n\";\n    }\n}\n/**\n * Singleton instance to the service, for internal usage only. Must NOT be exported to end user.\n */\nconst LOG4TS_PROVIDER_SERVICE = new Log4TSProviderService();\nconst LOG4TS_LOG_CONTROL = fnValue => LOG4TS_PROVIDER_SERVICE.getLog4TSControl(fnValue);\nfunction createDefaultLog4TSConfig() {\n    return {\n        argumentFormatter: formatArgument,\n        channel: DefaultChannels.createConsoleChannel(),\n        dateFormatter: formatDate,\n        groups: [],\n        level: LogLevel.Error,\n    };\n}\nfunction mergeLog4TSConfigs(lhs, rhs) {\n    const value = {\n        argumentFormatter: rhs.argumentFormatter ? rhs.argumentFormatter : lhs.argumentFormatter,\n        channel: rhs.channel ? rhs.channel : lhs.channel,\n        dateFormatter: rhs.dateFormatter ? rhs.dateFormatter : lhs.dateFormatter,\n        groups: [],\n        level: rhs.level !== undefined ? rhs.level : lhs.level,\n    };\n    /*\n     * Groups must take over the defaults from the main config when they don't specify config themselves.\n     */\n    value.groups = rhs.groups.map(groupConfig => mergeLog4TSGroupConfigs(value, groupConfig));\n    return value;\n}\nfunction mergeLog4TSGroupConfigs(lhs, rhs) {\n    return {\n        argumentFormatter: rhs.argumentFormatter ? rhs.argumentFormatter : lhs.argumentFormatter,\n        channel: lhs.channel,\n        dateFormatter: rhs.dateFormatter ? rhs.dateFormatter : lhs.dateFormatter,\n        expression: rhs.expression,\n        level: rhs.level !== undefined ? rhs.level : lhs.level,\n        identifier: rhs.identifier ? rhs.identifier : rhs.expression.toString(),\n    };\n}\nfunction validateLog4TSConfig(config) {\n    if (config.groups.length === 0) {\n        throw new Error(\"Invalid configuration, 'groups' on configuration is empty, at least 1 group config must be specified.\");\n    }\n}\n\n// tslint:disable-next-line:no-namespace\nvar Log4TSProvider;\n(function (Log4TSProvider) {\n    /**\n     * Creates a new log provider with given name and configuration. If a provider\n     * with such name already exists, an Error will be thrown.\n     * @param name Name for provider, must be unique\n     * @param config The config for the provider\n     */\n    function createProvider(name, config) {\n        return LOG4TS_PROVIDER_SERVICE.createLogProvider(name, config);\n    }\n    Log4TSProvider.createProvider = createProvider;\n    /**\n     * Resets and clears *all* created Log4TSProviders, every logger that was retrieved previously\n     * through any of them will be invalid afterwards.\n     *\n     * This call essentially reverts the created Log4TSProviders back to their initial state. This should normally not be used\n     * unless absolutely necessary.\n     */\n    function clear() {\n        LOG4TS_PROVIDER_SERVICE.clear();\n    }\n    Log4TSProvider.clear = clear;\n})(Log4TSProvider || (Log4TSProvider = {}));\n\nexport { LOG4TS_LOG_CONTROL, Log4TSProvider };\n//# sourceMappingURL=typescript-logging-log4ts.esm.js.map\n","\"use strict\";\n/*\n * StateMachine.ts\n * TypeScript finite state machine class with async transformations using promises.\n */\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _StateMachine_instances, _StateMachine_formatNoTransitionError;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StateMachine = void 0;\nexports.t = t;\nfunction t(fromState, event, toState, cb) {\n    return { fromState, event, toState, cb };\n}\nclass StateMachine {\n    // initialize the state-machine\n    constructor(init, transitions = [], logger = console) {\n        _StateMachine_instances.add(this);\n        this.init = init;\n        this.transitions = transitions;\n        this.logger = logger;\n        this._current = init;\n    }\n    addTransitions(transitions) {\n        // bind any unbound method\n        transitions.forEach((_tran) => {\n            const tran = Object.create(_tran);\n            if (tran.cb && !tran.cb.name?.startsWith(\"bound \")) {\n                tran.cb = tran.cb.bind(this);\n            }\n            this.transitions.push(tran);\n        });\n    }\n    getState() { return this._current; }\n    can(event) {\n        return this.transitions.some((trans) => (trans.fromState === this._current && trans.event === event));\n    }\n    getNextState(event) {\n        const transition = this.transitions.find((tran) => tran.fromState === this._current && tran.event === event);\n        return transition?.toState;\n    }\n    isFinal() {\n        // search for a transition that starts from current state.\n        // if none is found it's a terminal state.\n        return this.transitions.every((trans) => (trans.fromState !== this._current));\n    }\n    // post event async\n    async dispatch(event, ...args) {\n        return new Promise((resolve, reject) => {\n            // delay execution to make it async\n            setTimeout((me) => {\n                // find transition\n                const found = this.transitions.some((tran) => {\n                    if (tran.fromState === me._current && tran.event === event) {\n                        me._current = tran.toState;\n                        if (tran.cb) {\n                            try {\n                                const p = tran.cb(...args);\n                                if (p instanceof Promise) {\n                                    p.then(resolve).catch((e) => reject(e));\n                                }\n                                else {\n                                    resolve();\n                                }\n                            }\n                            catch (e) {\n                                this.logger.error(\"Exception caught in callback\", e);\n                                reject(e);\n                            }\n                        }\n                        else {\n                            resolve();\n                        }\n                        return true;\n                    }\n                    return false;\n                });\n                // no such transition\n                if (!found) {\n                    const errorMessage = __classPrivateFieldGet(this, _StateMachine_instances, \"m\", _StateMachine_formatNoTransitionError).call(this, me._current, event);\n                    this.logger.error(errorMessage);\n                    reject(new Error(errorMessage));\n                }\n            }, 0, this);\n        });\n    }\n    /**\n     * Generate a Mermaid StateDiagram of the current machine.\n     */\n    toMermaid(title) {\n        const diagram = [];\n        if (title) {\n            diagram.push(\"---\");\n            diagram.push(`title: ${title}`);\n            diagram.push(\"---\");\n        }\n        diagram.push(\"stateDiagram-v2\");\n        diagram.push(`  [*] --> ${String(this.init)}`);\n        this.transitions.forEach(({ event, fromState, toState }) => {\n            const from = String(fromState);\n            const to = String(toState);\n            const evt = String(event);\n            diagram.push(`  ${from} --> ${to}: ${evt}`);\n        });\n        // find terminal states\n        const ts = new Set();\n        this.transitions.forEach(({ toState }) => ts.add(toState));\n        this.transitions.forEach(({ fromState }) => ts.delete(fromState));\n        ts.forEach((state) => diagram.push(`  ${String(state)} --> [*]`));\n        return diagram.join(\"\\n\");\n    }\n}\nexports.StateMachine = StateMachine;\n_StateMachine_instances = new WeakSet(), _StateMachine_formatNoTransitionError = function _StateMachine_formatNoTransitionError(fromState, event) {\n    return `No transition: from ${String(fromState)} event ${String(event)}`;\n};\n//# sourceMappingURL=stateMachine.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/*--- config/LogConfig.ts ---*/\nimport { LogLevel } from \"typescript-logging\";\nimport { Log4TSProvider } from \"typescript-logging-log4ts-style\";\nexport const log4TSProvider = Log4TSProvider.createProvider(\"AwesomeLog4TSProvider\", {\n    level: LogLevel.Debug,\n    groups: [{\n            expression: new RegExp(\".+\"),\n        }]\n});\n","import { log4TSProvider } from \"../config/ConfigLog4j\";\nimport { t, StateMachine } from \"typescript-fsm\";\n// these are the states and events for the door\nvar States;\n(function (States) {\n    States[States[\"starting\"] = 0] = \"starting\";\n    States[States[\"ready\"] = 1] = \"ready\";\n    States[States[\"inference_ongoing\"] = 2] = \"inference_ongoing\";\n})(States || (States = {}));\n;\nvar Events;\n(function (Events) {\n    Events[Events[\"add_listner\"] = 100] = \"add_listner\";\n    Events[Events[\"start_inference\"] = 101] = \"start_inference\";\n    Events[Events[\"finish_inference\"] = 102] = \"finish_inference\";\n})(Events || (Events = {}));\n;\n// lets define the transitions that will govern the state-machine\nconst addFormListner = (e) => {\n    e.addEventListener('submit', onInferenceStarting, false);\n    log.debug('chat.ecollm.fr added form listener');\n};\nvar chatEventStartDate = null;\nconst finishInference = () => {\n    chatEventStartDate = null;\n};\nconst transitions = [\n    /* fromState        event                 toState         callback */\n    t(States.starting, Events.add_listner, States.ready, addFormListner),\n    t(States.ready, Events.start_inference, States.inference_ongoing, null),\n    t(States.inference_ongoing, Events.finish_inference, States.ready, null),\n];\n// initialize the state machine\nconst states = new StateMachine(States.starting, // initial state\ntransitions);\nconst log = log4TSProvider.getLogger(\"content-script-chat-ecollm.ts\");\nconst classNamesEnd = [\n    \"mt-1 flex justify-start gap-3 empty:hidden lg:flex text-xs\"\n];\n// const forms = document.getElementsByClassName('mx-auto flex w-full flex-row gap-3 transition-[max-width] duration-300 sm:px-2 md:max-w-3xl xl:max-w-4xl sm:mb-10');\nconst onInferenceStarting = () => {\n    chatEventStartDate = Date.now();\n    states.dispatch(Events.start_inference);\n    log.debug('chat.ecollm.fr inference starting');\n};\nconst observer = new MutationObserver((mutationsList, observer) => {\n    for (const mutation of mutationsList) {\n        if (mutation.type === 'childList') {\n            mutation.addedNodes.forEach((e) => {\n                if (states.getState() == States.starting) {\n                    const forms = e.getElementsByClassName('mx-auto flex w-full flex-row gap-3 transition-[max-width] duration-300 sm:px-2 md:max-w-3xl xl:max-w-4xl sm:mb-10');\n                    if (forms.length > 0) {\n                        states.dispatch(Events.add_listner, forms[0]);\n                        // forms[0].addEventListener('submit', onInferenceStarting, false);\n                        // log.debug('form listnener added !');\n                    }\n                }\n                else if (states.getState() == States.inference_ongoing) {\n                    // handle the case in which the window is updated with the new generated text\n                    // e.className ? log.debug('Received new node: ' + e.className):null;\n                    if (typeof e.className === \"string\" && classNamesEnd.includes(e.className)) {\n                        // const allNodes = document.querySelector(\".markdown.prose.message-content.dark\\\\:prose-invert.light.w-full.break-words.dark\\\\:text-gray-100\");\n                        const elts = document.querySelectorAll(\".markdown.prose.message-content.dark\\\\:prose-invert.light.w-full.break-words.dark\\\\:text-gray-100\");\n                        const lastEl = elts[elts.length - 1];\n                        const model = document.getElementsByClassName('flex-grow truncate text-left')[0].textContent;\n                        log.debug('chat.ecollm.fr model selected! : ' + model);\n                        log.debug('chat.ecollm.fr output finsihed! : ' + lastEl.textContent);\n                        log.debug('Window URL! : ' + document.location.href);\n                        var raw = {\n                            url: document.location.href, // \"https://chatgpt.com/\",\n                            body: \"{\\\"model\\\":\\\"\" + model + \"\\\"}\",\n                            generated_text: lastEl.textContent,\n                            starttime: chatEventStartDate,\n                            latency: Date.now() - chatEventStartDate,\n                        };\n                        // window.postMessage({ type: 'NEW_CHATEVENTRAW', chateventraw: raw }, '*');\n                        chrome.runtime.sendMessage(raw);\n                        states.dispatch(Events.finish_inference);\n                    }\n                }\n            });\n        }\n    }\n});\nobserver.observe(document.body, { childList: true, subtree: true });\n// Fonction utilitaire pour changer la couleur du background du prompt selon le texte\nfunction updatePromptBackgroundColor(text) {\n    const promptTextarea = document.getElementById('prompt-textarea');\n    if (!promptTextarea)\n        return;\n    let container = promptTextarea.closest('.relative.flex.w-full.items-end.px-3.py-3');\n    if (!container) {\n        container = promptTextarea.parentElement;\n    }\n    if (!container)\n        return;\n    if (/urgent/i.test(text)) {\n        container.style.backgroundColor = 'white';\n    }\n    else if (/important/i.test(text)) {\n        container.style.backgroundColor = 'white';\n    }\n    else if (text.trim() === '') {\n        container.style.backgroundColor = 'white'; // Par dfaut, vert si vide\n    }\n    else {\n        container.style.backgroundColor = 'white'; // Sinon, blanc\n    }\n}\n// Observer le champ d'dition pour dtecter les changements de texte\nfunction observePromptTextarea() {\n    const promptTextarea = document.getElementById('prompt-textarea');\n    if (!promptTextarea)\n        return;\n    // Ajoute un listener input sur le contenteditable\n    promptTextarea.addEventListener('input', () => {\n        const text = promptTextarea.textContent || '';\n        updatePromptBackgroundColor(text);\n    });\n    // Initialisation  l'ouverture\n    updatePromptBackgroundColor(promptTextarea.textContent || '');\n}\n// Comme le DOM peut changer dynamiquement, on observe l'apparition du prompt-textarea\nconst promptObserver = new MutationObserver(() => {\n    const promptTextarea = document.getElementById('prompt-textarea');\n    if (promptTextarea && !promptTextarea.hasAttribute('data-color-listener')) {\n        promptTextarea.setAttribute('data-color-listener', 'true');\n        observePromptTextarea();\n    }\n});\npromptObserver.observe(document.body, { childList: true, subtree: true });\n// Ajout dynamique d'un item EcoLLM dans le menu popup des discussions\nfunction insertEcoLLMMenuItem() {\n    // Cherche le menu popup (rle menu + classe popover)\n    const menu = document.querySelector('div[role=\"menu\"].popover');\n    if (!menu)\n        return;\n    // Vrifie si l'item existe dj\n    if (menu.querySelector('.ecollm-menu-item'))\n        return;\n    // Cre le nouvel item\n    const item = document.createElement('div');\n    item.setAttribute('role', 'menuitem');\n    item.setAttribute('tabindex', '0');\n    item.className = 'group __menu-item pe-8 gap-1.5 ecollm-menu-item';\n    item.style.cursor = 'pointer';\n    // Structure interne (logo extension + texte)\n    item.innerHTML = `\n    <div class=\"flex shrink-0 items-center justify-center h-[18px] w-[18px]\">\n      <svg t=\"1656468723058\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"18\" height=\"18\"><path d=\"M512 0C228.266667 0 0 228.266667 0 512s228.266667 512 512 512 512-228.266667 512-512S795.733333 0 512 0z m224 727.466667c0 23.466667-17.066667 40.533333-40.533333 40.533333H328.533333c-21.333333 0-40.533333-19.2-40.533333-40.533333V296.533333c0-23.466667 17.066667-40.533333 40.533333-40.533333h366.933334c21.333333 0 40.533333 19.2 40.533333 40.533333v430.933334z\" fill=\"#61dafb\"></path><path d=\"M473.6 727.466667h221.866667V411.733333H473.6v315.733334zM328.533333 727.466667h106.666667V411.733333h-106.666667v315.733334zM328.533333 296.533333v74.666667h369.066667V298.666667H328.533333z\" fill=\"#61dafb\"></path></svg>\n    </div>\n    EcoLLM\n  `;\n    // (Optionnel) Ajoute un handler au clic\n    item.addEventListener('click', () => {\n        alert('EcoLLM menu item clicked!');\n        // Ici tu peux ouvrir une page, afficher un panneau, etc.\n    });\n    // Ajoute l'item en haut du menu\n    menu.insertBefore(item, menu.firstChild);\n}\n// Observe l'apparition du menu popup\nconst menuObserver = new MutationObserver(() => {\n    insertEcoLLMMenuItem();\n});\nmenuObserver.observe(document.body, { childList: true, subtree: true });\nlog.debug(\"content-script-openai.js: Content script loaded!\");\n"],"names":["InternalLogLevel","LogLevel","DefaultChannels","_StateMachine_instances","_StateMachine_formatNoTransitionError","__classPrivateFieldGet","this","receiver","state","kind","f","TypeError","has","call","value","get","Object","defineProperty","exports","StateMachine","t","fromState","event","toState","cb","constructor","init","transitions","logger","console","add","_current","addTransitions","forEach","_tran","tran","create","name","startsWith","bind","push","getState","can","some","trans","getNextState","transition","find","isFinal","every","dispatch","args","Promise","resolve","reject","setTimeout","me","p","then","catch","e","error","errorMessage","Error","toMermaid","title","diagram","String","from","to","evt","ts","Set","delete","join","WeakSet","__webpack_module_cache__","EnhancedMap","Map","computeIfAbsent","key","computer","newValue","set","computeIfPresent","currentValue","undefined","compute","InternalLoggerImpl","level","fnOutput","_name","_level","_fnOutput","trace","msg","log","Trace","debug","Debug","info","Info","warn","Warn","setLevel","setOutput","toString","stack","InternalProviderImpl","_loggers","_logLevel","logConsole","getLogger","changeLogLevel","changeOutput","reset","toLogLevel","val","toLowerCase","Fatal","Off","ConsoleLogChannel","type","write","message","createConsoleChannel","setInternalLogLevel","freeze","__proto__","INTERNAL_LOGGING_SETTINGS","getInternalLogger","runtime","_runtime","id","logLevel","runtimeSettings","assign","logMessage","fatal","logMessageType","nowMillis","Date","now","errorAndArgs","getErrorAndArgs","channel","exception","timeInMillis","logNames","argumentFormatter","createLogMessage","formatArgValue","errorResult","dateFormatted","dateFormatter","levelAsStr","toUpperCase","length","map","arg","actualArgs","value0","slice","errorOrArgs","Array","isArray","fillChar","padType","charsNeeded","padding","i","JSON","stringify","millisSinceEpoch","date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","settings","_log","_settings","_idToKeyMap","_globalRuntimeSettings","_nextLoggerId","getOrCreateLogger","updateLoggerRuntime","currentKey","mergeRuntimeSettingsIntoLogRuntime","updateRuntimeSettings","clear","createKey","nextLoggerId","result","currentSettings","maxLengthStringValueInArray","arr","v","reduce","previous","current","padEnd","padStart","log4TSGroupConfigDebug","config","expression","Log4TSProviderImpl","defaultConfig","groupConfigs","_defaultConfig","identifier","_logProviders","updatedConfig","provider","groupConfig","groupProvLog","values","test","updateRuntimeSettingsGroup","updateLog4TGroupConfig","cfg","Log4TSControlProviderImpl","messageChannel","_provider","_messageChannel","_originalLogLevels","loadCurrentGroupLogLevels","showSettings","channelDescription","maxWidthIndex","maxWidthIdentifier","index$1","update","groupId","newLevel","groups","expectedGroup","save","localStorage","data","setItem","restore","logRestoreFailures","finalLogRestoreFailures","getItem","savedData","parse","restoreGroups","removeItem","help","saveData","logCannotRestore","group","Log4TSProviderService","_providers","createLogProvider","mainConfig","lhs","rhs","mergeLog4TSGroupConfigs","mergeLog4TSConfigs","validateLog4TSConfig","groupLog","g","log4TSConfigDebug","defaultExpression","RegExp","defaultGroupConfig","getLog4TSControl","fnValue","fnMessageChannel","getProvider","getLog4TSControlProviderByIdOrName","size","maxWidthName","keys","lines","entries","entry","providers","LOG4TS_PROVIDER_SERVICE","Log4TSProvider","createProvider","log4TSProvider","States","Events","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","chatEventStartDate","starting","add_listner","ready","addEventListener","onInferenceStarting","start_inference","inference_ongoing","finish_inference","states","classNamesEnd","updatePromptBackgroundColor","text","promptTextarea","document","getElementById","container","closest","parentElement","trim","style","backgroundColor","MutationObserver","mutationsList","observer","mutation","addedNodes","forms","getElementsByClassName","className","includes","elts","querySelectorAll","lastEl","model","textContent","location","href","raw","url","body","generated_text","starttime","latency","chrome","sendMessage","observe","childList","subtree","hasAttribute","setAttribute","observePromptTextarea","menu","querySelector","item","createElement","cursor","innerHTML","alert","insertBefore","firstChild","insertEcoLLMMenuItem"],"sourceRoot":""}