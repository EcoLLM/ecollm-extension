(()=>{"use strict";var e,t,r,n,o={186:function(e,t){var r,n,o=this&&this.__classPrivateFieldGet||function(e,t,r,n){if("a"===r&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!n:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===r?n:"a"===r?n.call(e):n?n.value:t.get(e)};Object.defineProperty(t,"__esModule",{value:!0}),t.StateMachine=void 0,t.t=function(e,t,r,n){return{fromState:e,event:t,toState:r,cb:n}},t.StateMachine=class{constructor(e,t=[],n=console){r.add(this),this.init=e,this.transitions=t,this.logger=n,this._current=e}addTransitions(e){e.forEach((e=>{const t=Object.create(e);t.cb&&!t.cb.name?.startsWith("bound ")&&(t.cb=t.cb.bind(this)),this.transitions.push(t)}))}getState(){return this._current}can(e){return this.transitions.some((t=>t.fromState===this._current&&t.event===e))}getNextState(e){const t=this.transitions.find((t=>t.fromState===this._current&&t.event===e));return t?.toState}isFinal(){return this.transitions.every((e=>e.fromState!==this._current))}async dispatch(e,...t){return new Promise(((i,s)=>{setTimeout((a=>{if(!this.transitions.some((r=>{if(r.fromState===a._current&&r.event===e){if(a._current=r.toState,r.cb)try{const e=r.cb(...t);e instanceof Promise?e.then(i).catch((e=>s(e))):i()}catch(e){this.logger.error("Exception caught in callback",e),s(e)}else i();return!0}return!1}))){const t=o(this,r,"m",n).call(this,a._current,e);this.logger.error(t),s(new Error(t))}}),0,this)}))}toMermaid(e){const t=[];e&&(t.push("---"),t.push(`title: ${e}`),t.push("---")),t.push("stateDiagram-v2"),t.push(`  [*] --\x3e ${String(this.init)}`),this.transitions.forEach((({event:e,fromState:r,toState:n})=>{const o=String(r),i=String(n),s=String(e);t.push(`  ${o} --\x3e ${i}: ${s}`)}));const r=new Set;return this.transitions.forEach((({toState:e})=>r.add(e))),this.transitions.forEach((({fromState:e})=>r.delete(e))),r.forEach((e=>t.push(`  ${String(e)} --\x3e [*]`))),t.join("\n")}},r=new WeakSet,n=function(e,t){return`No transition: from ${String(e)} event ${String(t)}`}}},i={};class s extends Map{computeIfAbsent(e,t){if(this.has(e))return this.get(e);const r=t(e);return this.set(e,r),r}computeIfPresent(e,t){const r=this.get(e);if(void 0===r)return;const n=t(e,r);return void 0!==n?this.set(e,n):this.delete(e),n}compute(e,t){const r=t(e,this.get(e));return r?this.set(e,r):this.delete(e),r}}!function(e){e[e.Trace=0]="Trace",e[e.Debug=1]="Debug",e[e.Info=2]="Info",e[e.Warn=3]="Warn",e[e.Error=4]="Error"}(e||(e={}));class a{constructor(e,t,r){this._name=e,this._level=t,this._fnOutput=r}trace(t){this.log(e.Trace,t)}debug(t){this.log(e.Debug,t)}error(t,r){this.log(e.Error,t,r)}info(t){this.log(e.Info,t)}warn(t,r){this.log(e.Warn,t,r)}setLevel(e){this._level=e}setOutput(e){this._fnOutput=e}log(t,r,n){this._level>t||this._fnOutput(`${e[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${r()}${n?"\n"+n.stack:""}`)}}class l{constructor(){this._loggers=new s,this._logLevel=e.Error,this._fnOutput=l.logConsole}getLogger(e){return this._loggers.computeIfAbsent(e,(e=>new a(e,this._logLevel,this._fnOutput)))}changeLogLevel(e){this._logLevel=e,this._loggers.forEach((t=>t.setLevel(e)))}changeOutput(e){this._fnOutput=e,this._loggers.forEach((e=>e.setOutput(this._fnOutput)))}reset(){this.changeLogLevel(e.Error),this._fnOutput=l.logConsole,this._loggers.forEach((e=>e.setOutput(this._fnOutput)))}static logConsole(e){console&&console.log&&console.log(e)}}new l,function(e){e[e.Trace=0]="Trace",e[e.Debug=1]="Debug",e[e.Info=2]="Info",e[e.Warn=3]="Warn",e[e.Error=4]="Error",e[e.Fatal=5]="Fatal",e[e.Off=6]="Off"}(t||(t={})),function(e){e.toLogLevel=function(t){switch(t.toLowerCase()){case"trace":return e.Trace;case"debug":return e.Debug;case"info":return e.Info;case"warn":return e.Warn;case"error":return e.Error;case"fatal":return e.Fatal;case"off":return e.Off;default:return}}}(t||(t={}));class g{constructor(){this.type="LogChannel"}write(e){console&&console.log&&console.log(e.message+(e.error?`\n${e.error}`:""))}}!function(e){e.createConsoleChannel=function(){return new g}}(r||(r={}));class u extends Map{computeIfAbsent(e,t){if(this.has(e))return this.get(e);const r=t(e);return this.set(e,r),r}computeIfPresent(e,t){const r=this.get(e);if(void 0===r)return;const n=t(e,r);return void 0!==n?this.set(e,n):this.delete(e),n}compute(e,t){const r=t(e,this.get(e));return r?this.set(e,r):this.delete(e),r}}function c(e){return f.getLogger(e)}!function(e){e[e.Trace=0]="Trace",e[e.Debug=1]="Debug",e[e.Info=2]="Info",e[e.Warn=3]="Warn",e[e.Error=4]="Error"}(n||(n={}));const h={setInternalLogLevel:e=>f.changeLogLevel(e),setOutput:e=>f.changeOutput(e),reset:()=>f.reset()};class d{constructor(e,t,r){this._name=e,this._level=t,this._fnOutput=r}trace(e){this.log(n.Trace,e)}debug(e){this.log(n.Debug,e)}error(e,t){this.log(n.Error,e,t)}info(e){this.log(n.Info,e)}warn(e,t){this.log(n.Warn,e,t)}setLevel(e){this._level=e}setOutput(e){this._fnOutput=e}log(e,t,r){this._level>e||this._fnOutput(`${n[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${t()}${r?"\n"+r.stack:""}`)}}class m{constructor(){this._loggers=new u,this._logLevel=n.Error,this._fnOutput=m.logConsole}getLogger(e){return this._loggers.computeIfAbsent(e,(e=>new d(e,this._logLevel,this._fnOutput)))}changeLogLevel(e){this._logLevel=e,this._loggers.forEach((t=>t.setLevel(e)))}changeOutput(e){this._fnOutput=e,this._loggers.forEach((e=>e.setOutput(this._fnOutput)))}reset(){this.changeLogLevel(n.Error),this._fnOutput=m.logConsole,this._loggers.forEach((e=>e.setOutput(this._fnOutput)))}static logConsole(e){console&&console.log&&console.log(e)}}const f=new m;var p,v,_=Object.freeze({__proto__:null,INTERNAL_LOGGING_SETTINGS:h,get InternalLogLevel(){return n},getInternalLogger:c});!function(e){e[e.Trace=0]="Trace",e[e.Debug=1]="Debug",e[e.Info=2]="Info",e[e.Warn=3]="Warn",e[e.Error=4]="Error",e[e.Fatal=5]="Fatal",e[e.Off=6]="Off"}(p||(p={})),function(e){e.toLogLevel=function(t){switch(t.toLowerCase()){case"trace":return e.Trace;case"debug":return e.Debug;case"info":return e.Info;case"warn":return e.Warn;case"error":return e.Error;case"fatal":return e.Fatal;case"off":return e.Off;default:return}}}(p||(p={}));class S{constructor(e){this._runtime=e}get id(){return this._runtime.id}get logLevel(){return this._runtime.level}get runtimeSettings(){return Object.assign({},this._runtime)}set runtimeSettings(e){this._runtime=e}trace(e,...t){this.logMessage(p.Trace,e,t)}debug(e,...t){this.logMessage(p.Debug,e,t)}info(e,...t){this.logMessage(p.Info,e,t)}warn(e,...t){this.logMessage(p.Warn,e,t)}error(e,...t){this.logMessage(p.Error,e,t)}fatal(e,...t){this.logMessage(p.Fatal,e,t)}logMessage(e,t,r){if(this._runtime.level>e)return;const n=Date.now(),o="string"==typeof t?t:t(),i=S.getErrorAndArgs(r);switch(this._runtime.channel.type){case"RawLogChannel":return void this._runtime.channel.write({message:o,exception:i.error,args:i.args,timeInMillis:n,level:e,logNames:this._runtime.name},this._runtime.argumentFormatter);case"LogChannel":this._runtime.channel.write(this.createLogMessage(o,e,i,n))}}formatArgValue(e){try{return this._runtime.argumentFormatter(e)}catch(t){return`>>ARG CONVERT FAILED: '${void 0!==e?e.toString():"undefined"}'<<`}}createLogMessage(e,t,r,n){let o;const i=r.error,s=r.args;i&&(o=`${i.name}: ${i.message}`,i.stack&&(o+=`@\n${i.stack}`));const a=this._runtime.dateFormatter(n);let l=p[t].toUpperCase();return l.length<5&&(l+=" "),{message:a+" "+l+" ["+("string"==typeof this._runtime.name?this._runtime.name:this._runtime.name.join(", "))+"] "+e+(void 0!==s&&s.length>0?" ["+s.map((e=>this.formatArgValue(e))).join(", ")+"]":""),error:o}}static getErrorAndArgs(e){if(0===e.length)return{};let t,r;const n=e[0];if(n instanceof Error)return t=n,r=e.length>1?e.slice(1):void 0,{error:t,args:r};if("function"==typeof n){const o=n();return o instanceof Error?(t=o,r=e.length>1?e.slice(1):void 0,{error:t,args:r}):1===e.length?Array.isArray(o)?{args:o.length>0?o:void 0}:{args:o}:Array.isArray(o)?{args:[...o,...e.slice(1)]}:{args:[o,...e.slice(1)]}}return{args:e}}}function E(e,t,r=" "){return L(e,t,"start",r)}function L(e,t,r,n=" "){if(t<=e.length)return e;if(n.length>1)throw new Error(`Fill char must be one char exactly, it is: ${n.length}`);const o=t-e.length;let i="";for(let e=0;e<o;e++)i+=n;return"start"===r?i+e:e+i}function C(e){return void 0===e?"undefined":JSON.stringify(e)}function w(e){const t=new Date(e);return`${t.getFullYear()}-${E((t.getMonth()+1).toString(),2,"0")}-${E(t.getDate().toString(),2,"0")} ${E(t.getHours().toString(),2,"0")}:${E(t.getMinutes().toString(),2,"0")}:${E(t.getSeconds().toString(),2,"0")},${E(t.getMilliseconds().toString(),3,"0")}`}class b{constructor(){this.type="LogChannel"}write(e){console&&console.log&&console.log(e.message+(e.error?`\n${e.error}`:""))}}!function(e){e.createConsoleChannel=function(){return new b}}(v||(v={}));class y{constructor(e,t){this._log=c("core.impl.LogProviderImpl"),this._name=e,this._settings=t,this._loggers=new u,this._idToKeyMap=new u,this._globalRuntimeSettings={level:t.level,channel:t.channel},this._nextLoggerId=1,this._log.trace((()=>`Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`))}get runtimeSettings(){return Object.assign(Object.assign({},this._settings),{level:this._globalRuntimeSettings.level,channel:this._globalRuntimeSettings.channel})}getLogger(e){return this.getOrCreateLogger(e)}updateLoggerRuntime(e,t){this._log.debug((()=>`Updating logger ${e.id} runtime settings using: '${JSON.stringify(t)}'`));const r=this._idToKeyMap.get(e.id);return void 0===r?(this._log.warn((()=>`Cannot update logger with id: ${e.id}, it was not found.`)),!1):(this._loggers.computeIfPresent(r,((e,r)=>(r.runtimeSettings=y.mergeRuntimeSettingsIntoLogRuntime(r.runtimeSettings,t),r))),!0)}updateRuntimeSettings(e){this._log.debug((()=>`Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(e)}'`)),this._globalRuntimeSettings={level:void 0!==e.level?e.level:this._globalRuntimeSettings.level,channel:void 0!==e.channel?e.channel:this._globalRuntimeSettings.channel},this._loggers.forEach((t=>t.runtimeSettings=y.mergeRuntimeSettingsIntoLogRuntime(t.runtimeSettings,e)))}clear(){this._loggers.clear(),this._idToKeyMap.clear(),this._globalRuntimeSettings=Object.assign({},this._settings),this._nextLoggerId=1}getOrCreateLogger(e){const t=y.createKey(e),r=this._loggers.computeIfAbsent(t,(()=>{const t={level:this._globalRuntimeSettings.level,channel:this._globalRuntimeSettings.channel,id:this.nextLoggerId(),name:e,argumentFormatter:this._settings.argumentFormatter,dateFormatter:this._settings.dateFormatter};return new S(t)}));return this._idToKeyMap.computeIfAbsent(r.id,(()=>t)),r}nextLoggerId(){const e=this._name+"_"+this._nextLoggerId;return this._nextLoggerId++,e}static mergeRuntimeSettingsIntoLogRuntime(e,t){return Object.assign(Object.assign({},e),{level:void 0!==t.level?t.level:e.level,channel:void 0!==t.channel?t.channel:e.channel})}static createKey(e){return"string"==typeof e?e:e.join(",")}}function I(e,t){return new y(e,t)}var N=Object.freeze({__proto__:null,EnhancedMap:u,maxLengthStringValueInArray:function(e){return e.map((e=>e.length)).reduce(((e,t)=>t>e?t:e),0)},padEnd:function(e,t,r=" "){return L(e,t,"end",r)},padStart:E});function T(e){return`Log4TSGroupConfig=level: ${p[e.level].toString()}, expression: ${e.expression.toString()}, (omitted functions/channel)`}class O{constructor(e,t,r){this._log=_.getInternalLogger("log4ts.impl.Log4TSProviderImpl"),this._name=e,this._defaultConfig=[Object.assign(Object.assign({},t),{identifier:t.identifier}),I("log4ts_"+e+"_"+t.identifier,t)],this._logProviders=new Map(r.map((t=>{const r=Object.assign({},t),n=I("log4ts_"+e+"_"+t.identifier,t);return[t.identifier,{groupConfig:r,provider:n}]}))),this._log.trace((()=>{const e=[...this._logProviders.values()].map((e=>T(e.groupConfig))).join(", ");return`Creating Log4TSProviderImpl '${this._name}', defaultConfig: ${T(this._defaultConfig[0])}, groupConfigs: ${e}`}))}get name(){return this._name}get config(){return Object.assign({},this._defaultConfig[0])}get groupConfigs(){return[...this._logProviders.values()].map((e=>Object.assign({},e.groupConfig)))}getLogger(e){for(const t of this._logProviders.values())if(t.groupConfig.expression.test(e))return t.provider.getLogger(e);return this._defaultConfig[1].getLogger(e)}updateRuntimeSettingsGroup(e,t){const r=this._logProviders.get(e);if(void 0===r)throw new Error(`Cannot update group with identifier '${e}', it does not exist.`);this._log.debug((()=>`Will update ${T(r.groupConfig)}, associated LogProvider '${r.provider}' - applying runtime change: ${JSON.stringify(t)}.`)),O.updateLog4TGroupConfig(r.groupConfig,r.provider,t)}updateRuntimeSettings(e){this._log.debug((()=>`Will update settings for all groups and existing loggers - will apply runtime change: ${JSON.stringify(e)}.`)),this._logProviders.forEach((t=>{const r=t.groupConfig,n=t.provider;this._log.debug((()=>`Will update ${T(r)}, associated LogProvider '${n}' - applying runtime change: ${JSON.stringify(e)}.`)),O.updateLog4TGroupConfig(r,n,e)}))}static updateLog4TGroupConfig(e,t,r){r.level&&(e.level=r.level),r.channel&&(e.channel=r.channel),t.updateRuntimeSettings(r)}}class ${constructor(e,t){this._provider=e,this._messageChannel=t,this._originalLogLevels=$.loadCurrentGroupLogLevels(e)}get name(){return this._provider.name}showSettings(){let e=`Available group configs (Log4TSProvider '${this._provider.name}'):\n`;const t=this._provider.groupConfigs.map((e=>({level:p[e.level],channelDescription:e.channel.toString?e.channel.toString():JSON.stringify(e.channel),identifier:e.identifier}))),r=t.length.toString().length,n=N.maxLengthStringValueInArray(t.map((e=>e.identifier)));e+=t.map(((e,t)=>`  [${N.padStart(t.toString(),r)}, ${N.padEnd(e.identifier,n)} (level=${N.padEnd(e.level,5)})]`)).join("\n")+"\n",this._messageChannel(e)}update(e,t){const r=p.toLogLevel(e);if(void 0===r)throw new Error(`Cannot update log provider, log level '${e}' is invalid.`);const n={level:r};if(void 0===t)return this._provider.updateRuntimeSettings(n),void this._messageChannel("Updated all group configs successfully.");if("number"==typeof t){const e=this._provider.groupConfigs;if(t<0||t>=e.length)throw new Error(`Group config with index '${t}' does not exist (outside of range).`);const r=e[t];return this._provider.updateRuntimeSettingsGroup(r.identifier,n),void this._messageChannel(`Updated group config with index '${t}' successfully.`)}this._provider.updateRuntimeSettingsGroup(t,n),this._messageChannel(`Updated group config with id '${t}' successfully.`)}reset(){this._originalLogLevels.forEach(((e,t)=>{this._provider.updateRuntimeSettingsGroup(t,{level:e})})),this._messageChannel("Successfully reset log levels back to original state (from when this Log4TSControlProvider was created).")}save(){if(!localStorage)return void this._messageChannel("Cannot save state, localStorage is not available.");const e={name:this._provider.name,groups:this._provider.groupConfigs.map((e=>({identifier:e.identifier,level:p[e.level]})))};localStorage.setItem(this.createKey(),JSON.stringify(e)),this._messageChannel(`Successfully saved state for Log4TSControlProvider '${this._provider.name}'.`)}restore(e){const t=void 0===e||e;if(!localStorage)return void(t&&this._messageChannel(`Will not attempt to restore state for Log4TSControlProvider '${this._provider.name}', localStorage is not available.`));const r=this.createKey(),n=localStorage.getItem(r);if(null!==n)try{const e=JSON.parse(n);if(this._provider.name!==e.name)return void(t&&this._messageChannel(`Cannot restore state for Log4TSControlProvider '${this._provider.name}', data is not for provider - found name '${e.name}'.`));this.restoreGroups(e,t),this._originalLogLevels=$.loadCurrentGroupLogLevels(this._provider)}catch(e){localStorage.removeItem(r),this._messageChannel(`Cannot restore state for Log4TSControlProvider '${this._provider.name}', data is not valid. Invalid data removed from localStorage.`)}else t&&this._messageChannel(`Cannot restore state for Log4TSControlProvider '${this._provider.name}', no data available.`)}help(){const e=`You can use the following commands (Log4TSProvider ${this._provider.name}):\n  showSettings()\n    Shows the current configuration settings.\n  update(logLevel: Log4TSControlProviderLogLevel, groupId?: number | string)\n    Change the log level for one or all config groups.\n      @param level   The log level to set - must be one of 'trace', 'debug', 'info', 'warn', 'error' or 'fatal'\n      @param groupId Optional group config to update by either index or identifier, when omitted updates all groups.\n                     Use showSettings() to find details about index and/or identifier.\n  reset()\n    Resets the log levels of the config groups back to when this control provider was created.\n  save()\n    Saves the current log levels for all config groups of this provider. Use restore() to load last saved state.\n  restore()\n    Restore stored saved state, if any. Log levels will be set according to saved state.\n  help()\n    Shows this help.\n`;this._messageChannel(e)}restoreGroups(e,t){e.groups.forEach((e=>{try{const r=p.toLogLevel(e.level);void 0!==r?(this._provider.updateRuntimeSettingsGroup(e.identifier,{level:r}),this._messageChannel(`Log4TSControlProvider '${this._provider.name}' - restored log level of group '${e.identifier}' to '${p[r]}'.`)):t&&this._messageChannel(`Log4TSControlProvider '${this._provider.name}' - failed to restore log level of group '${e.identifier}', invalid log level was specified.`)}catch(r){t&&this._messageChannel(`Log4TSControlProvider '${this._provider.name}' - failed to restore log level of group '${e.identifier}'.`)}}))}createKey(){return`Log4TSProvider-${this._provider.name}`}static loadCurrentGroupLogLevels(e){return new Map(e.groupConfigs.map((e=>[e.identifier,e.level])))}}class R{constructor(){this._log=_.getInternalLogger("log4ts.impl.Log4TSProviderService"),this._providers=new N.EnhancedMap}createLogProvider(e,t){const r=this._providers.compute(e,((r,n)=>{if(n)throw new Error(`Log4TSProvider with name '${e}' already exists, cannot create another.`);const o=function(e,t){const r={argumentFormatter:t.argumentFormatter?t.argumentFormatter:e.argumentFormatter,channel:t.channel?t.channel:e.channel,dateFormatter:t.dateFormatter?t.dateFormatter:e.dateFormatter,groups:[],level:void 0!==t.level?t.level:e.level};return r.groups=t.groups.map((e=>function(e,t){return{argumentFormatter:t.argumentFormatter?t.argumentFormatter:e.argumentFormatter,channel:e.channel,dateFormatter:t.dateFormatter?t.dateFormatter:e.dateFormatter,expression:t.expression,level:void 0!==t.level?t.level:e.level,identifier:t.identifier?t.identifier:t.expression.toString()}}(r,e))),r}({argumentFormatter:C,channel:v.createConsoleChannel(),dateFormatter:w,groups:[],level:p.Error},t);!function(e){if(0===e.groups.length)throw new Error("Invalid configuration, 'groups' on configuration is empty, at least 1 group config must be specified.")}(o),this._log.debug((()=>`Creating new Log4TSProvider with name '${e}', using main config settings '${function(e){const t=e.groups.map((e=>T(e))).join(", ");return`Log4TSGroupConfig=level: ${p[e.level].toString()}, groups: ${t}, (omitted functions/channel)`}(o)}'.`));const i=new RegExp(".+"),s={channel:o.channel,level:o.level,expression:i,dateFormatter:o.dateFormatter,argumentFormatter:o.argumentFormatter,identifier:i.toString()};return new O(r,s,o.groups)}));return r}clear(){this._providers.clear()}getLog4TSControl(e){const t=e||(e=>{if(!console||!console.log)throw new Error("Cannot use console (it is not present), please specify a custom function to write to.");console.log(e)});return{help:()=>t(R.help()),showSettings:()=>t(this.showSettings()),getProvider:e=>this.getLog4TSControlProviderByIdOrName(e,t)}}showSettings(){let e="Available Log4TSProviders:\n";const t=this._providers.size.toString().length,r=N.maxLengthStringValueInArray([...this._providers.keys()]),n=[...this._providers.entries()].map(((e,n)=>{const o=e[0];return`  [${N.padStart(n.toString(),t)}, ${N.padEnd(o,r)}]`}));return e+=n.join("\n")+(n.length>0?"\n":""),e}getLog4TSControlProviderByIdOrName(e,t){if("string"==typeof e){const r=this._providers.get(e);if(void 0===r)throw new Error(`Provider with name '${e}' does not exist.`);return new $(r,t)}const r=[...this._providers.values()];if(e<0||e>=r.length)throw new Error(`Provider with index '${e}' does not exist (outside of range).`);return new $(r[e],t)}static help(){return"You can use the following commands:\n  showSettings()\n    Shows the current configuration settings.\n  getProvider: (id: number | string): Log4TSControlProvider\n    Get access to a Log4TSControlProvider to change log levels.\n      @param id The id (use showSettings to see) or name of the provider\n  help()\n    Shows this help.\n"}}const A=new R;var F;!function(e){e.createProvider=function(e,t){return A.createLogProvider(e,t)},e.clear=function(){A.clear()}}(F||(F={}));const x=F.createProvider("AwesomeLog4TSProvider",{level:t.Debug,groups:[{expression:new RegExp(".+")}]});var P=function e(t){var r=i[t];if(void 0!==r)return r.exports;var n=i[t]={exports:{}};return o[t].call(n.exports,n,n.exports,e),n.exports}(186);const G=x.getLogger("EcoLLMStateMachine");var D,M;!function(e){e[e.STARTING=0]="STARTING",e[e.READY=1]="READY",e[e.INFERENCE_ONGOING=2]="INFERENCE_ONGOING"}(D||(D={})),function(e){e[e.ADD_LISTENER=100]="ADD_LISTENER",e[e.START_INFERENCE=101]="START_INFERENCE",e[e.FINISH_INFERENCE=102]="FINISH_INFERENCE"}(M||(M={}));const j=x.getLogger("content-script-copilot.ts"),q=new class{constructor(e){const t=[(0,P.t)(D.STARTING,M.ADD_LISTENER,D.READY,(t=>{G.debug("Transition: STARTING -> READY"),e&&e(t)})),(0,P.t)(D.READY,M.START_INFERENCE,D.INFERENCE_ONGOING,(()=>{G.debug("Transition: READY -> INFERENCE_ONGOING")})),(0,P.t)(D.INFERENCE_ONGOING,M.FINISH_INFERENCE,D.READY,(()=>{G.debug("Transition: INFERENCE_ONGOING -> READY")}))];this.machine=new P.StateMachine(D.STARTING,t)}dispatch(e,t){if(this.machine.can(e))try{this.machine.dispatch(e,t)}catch(t){G.warn(`Error dispatching event ${M[e]} from state ${D[this.machine.getState()]}: ${t}`)}else G.warn(`Cannot dispatch event ${M[e]} from state ${D[this.machine.getState()]}`)}getState(){return this.machine.getState()}};var W=null;const k=()=>{W=Date.now(),q.dispatch(M.START_INFERENCE),j.debug("Copilot inference starting!")};let K=null;function Y(){const e=document.querySelectorAll('[data-content="ai-message"]');if(e.length>0)return e;const t=document.querySelectorAll('[data-testid="message-item-reactions"]'),r=[];t.forEach((e=>{let t=e.parentElement,n=0;for(;t&&n<6;){if("ai-message"===t.getAttribute("data-content")||t.classList.toString().includes("ai-message")||t.querySelector('[data-content="ai-message"]')){r.push(t);break}t=t.parentElement,n++}}));const n=document.querySelectorAll('[data-content="ai-message"], [data-testid*="ai-message"], [class*="group/ai-message"], [class*="ai-message"]'),o=new Set([...Array.from(r),...Array.from(n)]);return Array.from(o)}let J=null;function U(e=document){return e.querySelector("textarea#userInput")}function V(e=document){var t;const r=U(e);return r&&(r.value.trim()||(null===(t=r.textContent)||void 0===t?void 0:t.trim()))||""}function H(e){const t="__extension_copilot_prompt_listeners_installed__";e[t]||(e[t]=!0,console.log("[Extension] Installing Copilot prompt listeners on",e===document?"top document":"iframe"),e.addEventListener("click",(t=>{const r=t.target;r&&(r.closest('button[type="submit"]')||r.closest('button[aria-label*="send" i]')||r.closest('button[title*="send" i]')||r.closest('[data-testid*="send"]'))&&V(e)&&(j.debug("Copilot send button clicked"),k())}),!0),e.addEventListener("keydown",(t=>{const r=t.target;if(!r)return;if(!r.closest("textarea#userInput"))return;if("Enter"!==t.key)return;const n=!(t.shiftKey||t.altKey||t.ctrlKey||t.metaKey),o=t.ctrlKey||t.metaKey;(n||o)&&V(e)&&(j.debug("Copilot Enter key pressed"),k())}),!0),e.addEventListener("submit",(t=>{var r;const n=t.target;n&&(n.closest("form")||(null===(r=U(e))||void 0===r?void 0:r.closest("form")))&&V(e)&&(j.debug("Copilot form submitted"),k())}),!0))}new MutationObserver((e=>{if(q.getState()!==D.INFERENCE_ONGOING)return;let t=!1;for(const r of e)"childList"===r.type&&r.addedNodes.forEach((e=>{var r,n,o,i,s;if(e.nodeType===Node.ELEMENT_NODE){const a=e;((null===(r=a.classList)||void 0===r?void 0:r.contains("group/ai-message-item"))||(null===(n=a.id)||void 0===n?void 0:n.includes("-content-"))||"message-item-reactions"===(null===(o=a.getAttribute)||void 0===o?void 0:o.call(a,"data-testid"))||(null===(i=a.querySelector)||void 0===i?void 0:i.call(a,'[data-testid="message-item-reactions"]'))||(null===(s=a.querySelector)||void 0===s?void 0:s.call(a,'[class*="group/ai-message-item"]')))&&(t=!0)}else e.nodeType===Node.TEXT_NODE&&(e.textContent||"").trim().length>0&&(t=!0)})),"characterData"===r.type&&(t=!0);t&&function(e=500){J&&clearTimeout(J),J=setTimeout((()=>{!async function(){if(q.getState()!==D.INFERENCE_ONGOING||!W)return;const e=Y();if(0===e.length)return;const t=e[e.length-1];if((r=t).querySelector(".streaming-animation")||r.querySelector('[class*="streaming"]')||r.querySelector('[class*="typing"]')||r.querySelector('[class*="loading"]')||"true"===r.getAttribute("aria-busy"))return void j.debug("Copilot message still streaming, waiting...");var r;let n=t.querySelector('[id*="-content-"]');var o;if(n||(n=t.querySelector('[class*="group/ai-message-item"]')),n&&(j.debug("Copilot waiting for animations to finish..."),await(o=n,new Promise((e=>{const t=[],r=[];[o,...Array.from(o.querySelectorAll("*"))].forEach((e=>{const n=window.getComputedStyle(e),o=n.animationName,i=n.transitionProperty;if(o&&"none"!==o){const r=new Promise((t=>{const r=n=>{n.target===e&&(e.removeEventListener("animationend",r),t())};e.addEventListener("animationend",r)}));t.push(r)}if(i&&"none"!==i){const t=new Promise((t=>{const r=n=>{n.target!==e||"opacity"!==n.propertyName&&"all"!==n.propertyName||(e.removeEventListener("transitionend",r),t())};e.addEventListener("transitionend",r)}));r.push(t)}})),0!==t.length||0!==r.length?(Promise.all([...t,...r]).then((()=>{setTimeout(e,100)})),setTimeout((()=>{e()}),5e3)):e()})))),q.getState()!==D.INFERENCE_ONGOING||!W)return;const i=Y();if(0===i.length)return;const s=function(e){let t=e.querySelector('[id*="-content-"]');if(t||(t=e.querySelector('[class*="group/ai-message-item"]')),t)return t.textContent||t.innerText||"";const r=e.cloneNode(!0);return r.querySelectorAll('.sr-only, [class*="sr-only"]').forEach((e=>e.remove())),r.textContent||r.innerText||""}(i[i.length-1]).trim();if(!s||"Copilot said"===s)return void j.debug("Copilot: No valid text found in message");const a=s.substring(0,100)+s.length;if(a===K)return;K=a,j.debug("Copilot inference done!"),j.debug("Copilot extracted text length: "+s.length);const l=function(){const e=document.querySelector('[data-testid="composer-chat-mode-smart-button"]')||document.querySelector('[data-testid*="chat-mode"]')||document.querySelector('button[title*="GPT"]');let t="gpt-4";if(e){const r=e.textContent||e.getAttribute("title")||"";j.debug("Copilot model button text: "+r);const n=r.match(/GPT[-\s]?(\d+)/i)||r.match(/(gpt[-\s]?\d+)/i);n?(t=n[0].toLowerCase().replace(/\s+/g,"-"),t.startsWith("gpt-")||(t="gpt-"+t.replace("gpt","").trim())):r.toLowerCase().includes("smart")&&(t="gpt-4")}return t}();j.debug("Copilot model selected: "+l);const g={url:document.location.href,body:'{"model":"'+l+'"}',generated_text:s,starttime:W,latency:Date.now()-W};chrome.runtime.sendMessage(g),W=null,q.dispatch(M.FINISH_INFERENCE)}()}),e)}()})).observe(document.body,{childList:!0,subtree:!0,characterData:!0}),function(){var e;H(document);const t=Array.from(document.querySelectorAll("iframe"));for(const r of t)try{const t=r.contentDocument||(null===(e=r.contentWindow)||void 0===e?void 0:e.document)||null;t&&H(t)}catch(e){}}(),q.dispatch(M.ADD_LISTENER),j.debug("content-script-copilot.ts: Content script loaded!")})();
//# sourceMappingURL=content-script-copilot.js.map