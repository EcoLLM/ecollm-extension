{"version":3,"file":"content-script-openai.js","mappings":"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","sources":["webpack://ecollm-chrome-extension/./node_modules/typescript-logging/dist/bundle/typescript-logging.esm.js","webpack://ecollm-chrome-extension/./node_modules/typescript-logging-log4ts-style/dist/bundle/typescript-logging-log4ts.esm.js","webpack://ecollm-chrome-extension/./src/config/ConfigLog4j.ts","webpack://ecollm-chrome-extension/./src/content-scripts/content-script-openai.ts"],"sourcesContent":["/**\n * Extends Map and adds a few convenient functions.\n */\nclass EnhancedMap extends Map {\n    /**\n     * If key has a mapping already returns the currently associated value. If\n     * there is no mapping, calls the computer which must return a value V.\n     * The value is then stored for given key and returned.\n     * @param key Key\n     * @param computer Computer which is called only if key has no mapping yet.\n     * @return Existing value if the key already existed, or the newly computed value.\n     */\n    computeIfAbsent(key, computer) {\n        if (this.has(key)) {\n            return this.get(key);\n        }\n        const newValue = computer(key);\n        this.set(key, newValue);\n        return newValue;\n    }\n    /**\n     * If the key exists already calls given computer, if the key does not exist\n     * this method does nothing.\n     *\n     * The computer is called with current key and current value associated. The\n     * computer can return a (new) value V or undefined. When undefined is returned\n     * the key is removed from this map, when a V is returned the key is updated\n     * with the new value V.\n     * @param key Key\n     * @param computer Computer which is called only if the key has a mapping already\n     * @return Undefined if the key has no mapping, otherwise the value returned from computer\n     */\n    computeIfPresent(key, computer) {\n        const currentValue = this.get(key);\n        if (currentValue === undefined) {\n            return undefined;\n        }\n        const newValue = computer(key, currentValue);\n        if (newValue !== undefined) {\n            this.set(key, newValue);\n        }\n        else {\n            this.delete(key);\n        }\n        return newValue;\n    }\n    /**\n     * Computes a value for given key, the computer can return a value V (in which case the map\n     * will set the value for given key), if it returns undefined the mapping for key K will be\n     * removed.\n     * @param key Key to compute\n     * @param computer Computer which is called, note that the currentValue argument contains the existing\n     *                 value or is undefined when no mapping exists for the key.\n     * @return The newly computed value\n     */\n    compute(key, computer) {\n        const currentValue = this.get(key);\n        const newValue = computer(key, currentValue);\n        if (newValue) {\n            this.set(key, newValue);\n        }\n        else {\n            this.delete(key);\n        }\n        return newValue;\n    }\n}\n\n/**\n * Internal log level (note: do NOT use LogLevel, or we get circular loading issues!)\n */\nvar InternalLogLevel;\n(function (InternalLogLevel) {\n    InternalLogLevel[InternalLogLevel[\"Trace\"] = 0] = \"Trace\";\n    InternalLogLevel[InternalLogLevel[\"Debug\"] = 1] = \"Debug\";\n    InternalLogLevel[InternalLogLevel[\"Info\"] = 2] = \"Info\";\n    InternalLogLevel[InternalLogLevel[\"Warn\"] = 3] = \"Warn\";\n    InternalLogLevel[InternalLogLevel[\"Error\"] = 4] = \"Error\";\n})(InternalLogLevel || (InternalLogLevel = {}));\n/**\n * Internal logger, this is NOT for end users. Instead this is used to enable logging for typescript-logging itself in case of problems.\n *\n * @param name Name of logger\n */\nfunction getInternalLogger(name) {\n    return provider.getLogger(name);\n}\n/**\n * Can be used to change the *internal* logging of the library.\n * Has no effect on end user logging.\n *\n * As such should normally not be used by end users.\n */\nconst INTERNAL_LOGGING_SETTINGS = {\n    /**\n     * Changes the log level for the internal logging (for all new and existing loggers)\n     * @param level New log level\n     */\n    setInternalLogLevel: (level) => provider.changeLogLevel(level),\n    /**\n     * Changes where messages are written to for all new and existing loggers),\n     * by default they are written to the console.\n     * @param fnOutput Function to write messages to\n     */\n    setOutput: (fnOutput) => provider.changeOutput(fnOutput),\n    /**\n     * Resets the log level and output back to defaults (level to error and writing to console)\n     * for all new and existing loggers.\n     */\n    reset: () => provider.reset(),\n};\nclass InternalLoggerImpl {\n    constructor(name, level, fnOutput) {\n        this._name = name;\n        this._level = level;\n        this._fnOutput = fnOutput;\n    }\n    trace(msg) {\n        this.log(InternalLogLevel.Trace, msg);\n    }\n    debug(msg) {\n        this.log(InternalLogLevel.Debug, msg);\n    }\n    error(msg, error) {\n        this.log(InternalLogLevel.Error, msg, error);\n    }\n    info(msg) {\n        this.log(InternalLogLevel.Info, msg);\n    }\n    warn(msg, error) {\n        this.log(InternalLogLevel.Warn, msg, error);\n    }\n    setLevel(level) {\n        this._level = level;\n    }\n    setOutput(fnOutput) {\n        this._fnOutput = fnOutput;\n    }\n    log(level, msg, error) {\n        if (this._level > level) {\n            return;\n        }\n        // tslint:disable-next-line:no-console\n        this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${msg()}${error ? \"\\n\" + error.stack : \"\"}`);\n    }\n}\nclass InternalProviderImpl {\n    constructor() {\n        this._loggers = new EnhancedMap();\n        this._logLevel = InternalLogLevel.Error;\n        this._fnOutput = InternalProviderImpl.logConsole;\n    }\n    getLogger(name) {\n        return this._loggers.computeIfAbsent(name, key => new InternalLoggerImpl(key, this._logLevel, this._fnOutput));\n    }\n    changeLogLevel(level) {\n        this._logLevel = level;\n        this._loggers.forEach(logger => logger.setLevel(level));\n    }\n    changeOutput(_fnOutput) {\n        this._fnOutput = _fnOutput;\n        this._loggers.forEach(logger => logger.setOutput(this._fnOutput));\n    }\n    reset() {\n        this.changeLogLevel(InternalLogLevel.Error);\n        this._fnOutput = InternalProviderImpl.logConsole;\n        this._loggers.forEach(logger => logger.setOutput(this._fnOutput));\n    }\n    static logConsole(msg) {\n        // tslint:disable-next-line:no-console\n        if (console && console.log) {\n            // tslint:disable-next-line:no-console\n            console.log(msg);\n        }\n    }\n}\nconst provider = new InternalProviderImpl();\n\nvar InternalLogger = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS,\n  get InternalLogLevel () { return InternalLogLevel; },\n  getInternalLogger: getInternalLogger\n});\n\n/**\n * Log level for a logger.\n */\nvar LogLevel;\n(function (LogLevel) {\n    // Do not change values/order. Logging a message relies on this.\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 3] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n    LogLevel[LogLevel[\"Fatal\"] = 5] = \"Fatal\";\n    LogLevel[LogLevel[\"Off\"] = 6] = \"Off\";\n})(LogLevel || (LogLevel = {}));\n/* tslint:disable:no-namespace */\n(function (LogLevel) {\n    /**\n     * Convert given value to LogLevel, if not matching returns undefined.\n     * @param val Value to convert\n     */\n    function toLogLevel(val) {\n        switch (val.toLowerCase()) {\n            case \"trace\":\n                return LogLevel.Trace;\n            case \"debug\":\n                return LogLevel.Debug;\n            case \"info\":\n                return LogLevel.Info;\n            case \"warn\":\n                return LogLevel.Warn;\n            case \"error\":\n                return LogLevel.Error;\n            case \"fatal\":\n                return LogLevel.Fatal;\n            case \"off\":\n                return LogLevel.Off;\n            default:\n                return undefined;\n        }\n    }\n    LogLevel.toLogLevel = toLogLevel;\n})(LogLevel || (LogLevel = {}));\n/* tslint:disable:enable-namespace */\n\n/**\n * Standard logger implementation that provides the basis for all loggers.\n */\nclass CoreLoggerImpl {\n    constructor(runtime) {\n        this._runtime = runtime;\n    }\n    get id() {\n        return this._runtime.id;\n    }\n    get logLevel() {\n        return this._runtime.level;\n    }\n    get runtimeSettings() {\n        /* Return it as new literal, we don't want people to play with our internal state */\n        return Object.assign({}, this._runtime);\n    }\n    set runtimeSettings(runtime) {\n        this._runtime = runtime;\n    }\n    trace(message, ...args) {\n        this.logMessage(LogLevel.Trace, message, args);\n    }\n    debug(message, ...args) {\n        this.logMessage(LogLevel.Debug, message, args);\n    }\n    info(message, ...args) {\n        this.logMessage(LogLevel.Info, message, args);\n    }\n    warn(message, ...args) {\n        this.logMessage(LogLevel.Warn, message, args);\n    }\n    error(message, ...args) {\n        this.logMessage(LogLevel.Error, message, args);\n    }\n    fatal(message, ...args) {\n        this.logMessage(LogLevel.Fatal, message, args);\n    }\n    logMessage(level, logMessageType, args) {\n        if (this._runtime.level > level) {\n            return;\n        }\n        const nowMillis = Date.now();\n        const message = typeof logMessageType === \"string\" ? logMessageType : logMessageType();\n        const errorAndArgs = CoreLoggerImpl.getErrorAndArgs(args);\n        /*\n         * Deal with raw message here.\n         */\n        switch (this._runtime.channel.type) {\n            case \"RawLogChannel\":\n                this._runtime.channel.write({\n                    message,\n                    exception: errorAndArgs.error,\n                    args: errorAndArgs.args,\n                    timeInMillis: nowMillis,\n                    level,\n                    logNames: this._runtime.name,\n                }, this._runtime.argumentFormatter);\n                return;\n            case \"LogChannel\":\n                this._runtime.channel.write(this.createLogMessage(message, level, errorAndArgs, nowMillis));\n                break;\n        }\n    }\n    formatArgValue(value) {\n        try {\n            return this._runtime.argumentFormatter(value);\n        }\n        catch (e) {\n            // We don't really care what failed, except that the convert function failed.\n            return `>>ARG CONVERT FAILED: '${value !== undefined ? value.toString() : \"undefined\"}'<<`;\n        }\n    }\n    createLogMessage(message, level, errorAndArgs, nowMillis) {\n        let errorResult;\n        const error = errorAndArgs.error;\n        const args = errorAndArgs.args;\n        if (error) {\n            errorResult = `${error.name}: ${error.message}`;\n            if (error.stack) {\n                errorResult += `@\\n${error.stack}`;\n            }\n        }\n        /*\n         * We need to add the date, and log names (in front of the now formatted message).\n         * Finally we also need to format any additional arguments and append after the message.\n         */\n        const dateFormatted = this._runtime.dateFormatter(nowMillis);\n        let levelAsStr = LogLevel[level].toUpperCase();\n        if (levelAsStr.length < 5) {\n            levelAsStr += \" \";\n        }\n        const names = typeof this._runtime.name === \"string\" ? this._runtime.name : this._runtime.name.join(\", \");\n        const argsFormatted = typeof args !== \"undefined\" && args.length > 0 ? (\" [\" + (args.map(arg => this.formatArgValue(arg))).join(\", \") + \"]\") : \"\";\n        const completedMessage = dateFormatted + \" \" + levelAsStr + \" [\" + names + \"] \" + message + argsFormatted;\n        return {\n            message: completedMessage,\n            error: errorResult,\n        };\n    }\n    static getErrorAndArgs(args) {\n        /*\n          The args are optional, but the first entry may be an Error or a function to an Error, or finally be a function to extra arguments.\n          The last is only true, if the length of args === 1, otherwise we expect args starting at pos 1 and further to be just that - args.\n         */\n        if (args.length === 0) {\n            return {};\n        }\n        let error;\n        let actualArgs;\n        const value0 = args[0];\n        /* If the first argument is an Error, we can stop straight away, the rest are additional arguments then if any */\n        if (value0 instanceof Error) {\n            error = value0;\n            actualArgs = args.length > 1 ? args.slice(1) : undefined;\n            return { error, args: actualArgs };\n        }\n        /* If the first argument is a function, it means either it will return the Error, or if the array length === 1 a function, returning the arguments */\n        if (typeof value0 === \"function\") {\n            const errorOrArgs = value0();\n            if (errorOrArgs instanceof Error) {\n                error = errorOrArgs;\n                actualArgs = args.length > 1 ? args.slice(1) : undefined;\n                return { error, args: actualArgs };\n            }\n            if (args.length === 1) {\n                /* The first argument was a function, we assume it returned the extra argument(s) */\n                if (Array.isArray(errorOrArgs)) {\n                    return { args: errorOrArgs.length > 0 ? errorOrArgs : undefined };\n                }\n                else {\n                    /* No idea what was returned we just assume a single value */\n                    return { args: errorOrArgs };\n                }\n            }\n            else {\n                /*\n                  This is a weird situation but there's no way to avoid it, the first argument was a function but did not return an Error and the args are > 1,\n                  so just add the args returned, as well as any remaining.\n                */\n                if (Array.isArray(errorOrArgs)) {\n                    return { args: [...errorOrArgs, ...args.slice(1)] };\n                }\n                return { args: [errorOrArgs, ...args.slice(1)] };\n            }\n        }\n        /* All args are ordinary arguments, or at least the first arg was not an Error or a Function, so we add all as args */\n        return { args };\n    }\n}\n\n/**\n * Pad given value with given fillChar from the beginning (default is an empty space)\n * @param value Value to pad\n * @param length The length the string must be\n * @param fillChar The padding char (1 char length allowed only)\n * @return Padded string or the same string if it is already of given length (or larger).\n */\nfunction padStart(value, length, fillChar = \" \") {\n    return padInternal(value, length, \"start\", fillChar);\n}\n/**\n * Pad given value with given fillChar from the end (default is an empty space)\n * @param value Value to pad\n * @param length The length the string must be\n * @param fillChar The padding char (1 char length allowed only)\n * @return Padded string or the same string if it is already of given length (or larger).\n */\nfunction padEnd(value, length, fillChar = \" \") {\n    return padInternal(value, length, \"end\", fillChar);\n}\n/**\n * Returns the max length of a string value in given array\n * @param arr Array to check\n * @return Max length, 0 if array is empty\n */\nfunction maxLengthStringValueInArray(arr) {\n    return arr\n        .map(v => v.length)\n        .reduce((previous, current) => {\n        if (current > previous) {\n            return current;\n        }\n        return previous;\n    }, 0);\n}\nfunction padInternal(value, length, padType, fillChar = \" \") {\n    if (length <= value.length) {\n        return value;\n    }\n    if (fillChar.length > 1) {\n        throw new Error(`Fill char must be one char exactly, it is: ${fillChar.length}`);\n    }\n    const charsNeeded = length - value.length;\n    let padding = \"\";\n    for (let i = 0; i < charsNeeded; i++) {\n        padding += fillChar;\n    }\n    if (padType === \"start\") {\n        return padding + value;\n    }\n    return value + padding;\n}\n\n/**\n * Default argument formatter function, used by the library, see {@link ArgumentFormatterType}.\n * Can be used by an end user as well if needed.\n * @param arg The argument to format\n * @returns argument stringified to string (JSON.stringify), if arg is undefined returns \"undefined\" (without quotes).\n */\nfunction formatArgument(arg) {\n    if (arg === undefined) {\n        return \"undefined\";\n    }\n    return JSON.stringify(arg);\n}\n/**\n * Default date formatter function, used by the library, see {@link DateFormatterType}.\n * Can be used by an end user as well if needed.\n * @param millisSinceEpoch Milliseconds since epoch\n * @returns The date in format: yyyy-MM-dd HH:mm:ss,SSS (example: 2021-02-26 09:06:28,123)\n */\nfunction formatDate(millisSinceEpoch) {\n    const date = new Date(millisSinceEpoch);\n    const year = date.getFullYear();\n    const month = padStart((date.getMonth() + 1).toString(), 2, \"0\");\n    const day = padStart(date.getDate().toString(), 2, \"0\");\n    const hours = padStart(date.getHours().toString(), 2, \"0\");\n    const minutes = padStart(date.getMinutes().toString(), 2, \"0\");\n    const seconds = padStart(date.getSeconds().toString(), 2, \"0\");\n    const millis = padStart(date.getMilliseconds().toString(), 3, \"0\");\n    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds},${millis}`;\n}\n\n/* tslint:disable:no-console */\n/**\n * Default standard LogChannel which logs to console.\n */\nclass ConsoleLogChannel {\n    constructor() {\n        this.type = \"LogChannel\";\n    }\n    write(msg) {\n        if (console && console.log) {\n            console.log(msg.message + (msg.error ? `\\n${msg.error}` : \"\"));\n        }\n    }\n}\n\n/* tslint:disable:no-namespace */\n/**\n * Provides access to various default channels provided by typescript logging.\n */\nvar DefaultChannels;\n(function (DefaultChannels) {\n    /**\n     * Create a new standard LogChannel that logs to the console.\n     */\n    function createConsoleChannel() {\n        return new ConsoleLogChannel();\n    }\n    DefaultChannels.createConsoleChannel = createConsoleChannel;\n})(DefaultChannels || (DefaultChannels = {}));\n\n/**\n * Implementation for {@link LogProvider}\n */\nclass LogProviderImpl {\n    constructor(name, settings) {\n        this._log = getInternalLogger(\"core.impl.LogProviderImpl\");\n        this._name = name;\n        this._settings = settings;\n        this._loggers = new EnhancedMap();\n        this._idToKeyMap = new EnhancedMap();\n        this._globalRuntimeSettings = { level: settings.level, channel: settings.channel };\n        this._nextLoggerId = 1;\n        this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);\n    }\n    get runtimeSettings() {\n        return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });\n    }\n    getLogger(name) {\n        return this.getOrCreateLogger(name);\n    }\n    updateLoggerRuntime(log, settings) {\n        this._log.debug(() => `Updating logger ${log.id} runtime settings using: '${JSON.stringify(settings)}'`);\n        const key = this._idToKeyMap.get(log.id);\n        if (key === undefined) {\n            this._log.warn(() => `Cannot update logger with id: ${log.id}, it was not found.`);\n            return false;\n        }\n        this._loggers.computeIfPresent(key, (currentKey, currentValue) => {\n            currentValue.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(currentValue.runtimeSettings, settings);\n            return currentValue;\n        });\n        return true;\n    }\n    updateRuntimeSettings(settings) {\n        this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(settings)}'`);\n        this._globalRuntimeSettings = {\n            /*\n             * Undefined check is necessary, as level is a number (and LogLevel.Trace = 0), a ternary check otherwise results in the annoying \"truthy/falsy\"\n             * behavior of javascript where 0 is seen as false.\n             */\n            level: settings.level !== undefined ? settings.level : this._globalRuntimeSettings.level,\n            channel: settings.channel !== undefined ? settings.channel : this._globalRuntimeSettings.channel,\n        };\n        this._loggers.forEach(logger => logger.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(logger.runtimeSettings, settings));\n    }\n    /**\n     * Removes all state and loggers, it reverts back to as it was after initial construction.\n     */\n    clear() {\n        this._loggers.clear();\n        this._idToKeyMap.clear();\n        this._globalRuntimeSettings = Object.assign({}, this._settings);\n        this._nextLoggerId = 1;\n    }\n    getOrCreateLogger(name) {\n        const key = LogProviderImpl.createKey(name);\n        const logger = this._loggers.computeIfAbsent(key, () => {\n            const runtime = {\n                level: this._globalRuntimeSettings.level,\n                channel: this._globalRuntimeSettings.channel,\n                id: this.nextLoggerId(),\n                name,\n                argumentFormatter: this._settings.argumentFormatter,\n                dateFormatter: this._settings.dateFormatter,\n            };\n            return new CoreLoggerImpl(runtime);\n        });\n        this._idToKeyMap.computeIfAbsent(logger.id, () => key);\n        return logger;\n    }\n    nextLoggerId() {\n        const result = this._name + \"_\" + this._nextLoggerId;\n        this._nextLoggerId++;\n        return result;\n    }\n    static mergeRuntimeSettingsIntoLogRuntime(currentSettings, settings) {\n        return Object.assign(Object.assign({}, currentSettings), { \n            /*\n             * Undefined check is necessary, as level is a number (and LogLevel.Trace = 0), a ternary check otherwise results in the annoying \"truthy/falsy\"\n             * behavior of javascript where 0 is seen as false.\n             */\n            level: settings.level !== undefined ? settings.level : currentSettings.level, channel: settings.channel !== undefined ? settings.channel : currentSettings.channel });\n    }\n    static createKey(name) {\n        if (typeof name === \"string\") {\n            return name;\n        }\n        return name.join(\",\");\n    }\n}\n\n/**\n * Create a new LogProvider, this is for flavor usage only. End users should not\n * use this and instead use whatever the flavor offers to build some config and\n * get loggers from there.\n */\nfunction createLogProvider(name, settings) {\n    return new LogProviderImpl(name, settings);\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  EnhancedMap: EnhancedMap,\n  maxLengthStringValueInArray: maxLengthStringValueInArray,\n  padEnd: padEnd,\n  padStart: padStart\n});\n\n/**\n * LogChannel that pushes log messages to a buffer.\n */\nclass ArrayLogChannel {\n    constructor() {\n        this._buffer = [];\n        this.type = \"LogChannel\";\n    }\n    write(msg) {\n        this._buffer.push(msg);\n    }\n    get logMessages() {\n        return this._buffer;\n    }\n    get messages() {\n        return this._buffer.map(msg => msg.message);\n    }\n}\n/**\n * RawLogChannel that pushes raw log messages to a buffer.\n */\nclass ArrayRawLogChannel {\n    constructor() {\n        this._buffer = [];\n        this.type = \"RawLogChannel\";\n    }\n    write(msg, _) {\n        this._buffer.push(msg);\n    }\n    get messages() {\n        return this._buffer.map(m => m.message);\n    }\n    get errors() {\n        return this._buffer.map(m => m.exception);\n    }\n    get size() {\n        return this._buffer.length;\n    }\n    get rawMessages() {\n        return this._buffer;\n    }\n    clear() {\n        this._buffer = [];\n    }\n}\n/**\n * Test class to help test the log control.\n */\nclass TestControlMessage {\n    constructor() {\n        this._messages = [];\n        this.write = this.write.bind(this);\n    }\n    get messages() {\n        return this._messages;\n    }\n    write(msg) {\n        this._messages.push(msg);\n    }\n    clear() {\n        this._messages = [];\n    }\n}\n\nvar TestClasses = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ArrayLogChannel: ArrayLogChannel,\n  ArrayRawLogChannel: ArrayRawLogChannel,\n  TestControlMessage: TestControlMessage\n});\n\nexport { InternalLogger as $internal, TestClasses as $test, DefaultChannels, LogLevel, createLogProvider, formatArgument, formatDate, index as util };\n//# sourceMappingURL=typescript-logging.esm.js.map\n","/**\n * Extends Map and adds a few convenient functions.\n */\nclass EnhancedMap extends Map {\n    /**\n     * If key has a mapping already returns the currently associated value. If\n     * there is no mapping, calls the computer which must return a value V.\n     * The value is then stored for given key and returned.\n     * @param key Key\n     * @param computer Computer which is called only if key has no mapping yet.\n     * @return Existing value if the key already existed, or the newly computed value.\n     */\n    computeIfAbsent(key, computer) {\n        if (this.has(key)) {\n            return this.get(key);\n        }\n        const newValue = computer(key);\n        this.set(key, newValue);\n        return newValue;\n    }\n    /**\n     * If the key exists already calls given computer, if the key does not exist\n     * this method does nothing.\n     *\n     * The computer is called with current key and current value associated. The\n     * computer can return a (new) value V or undefined. When undefined is returned\n     * the key is removed from this map, when a V is returned the key is updated\n     * with the new value V.\n     * @param key Key\n     * @param computer Computer which is called only if the key has a mapping already\n     * @return Undefined if the key has no mapping, otherwise the value returned from computer\n     */\n    computeIfPresent(key, computer) {\n        const currentValue = this.get(key);\n        if (currentValue === undefined) {\n            return undefined;\n        }\n        const newValue = computer(key, currentValue);\n        if (newValue !== undefined) {\n            this.set(key, newValue);\n        }\n        else {\n            this.delete(key);\n        }\n        return newValue;\n    }\n    /**\n     * Computes a value for given key, the computer can return a value V (in which case the map\n     * will set the value for given key), if it returns undefined the mapping for key K will be\n     * removed.\n     * @param key Key to compute\n     * @param computer Computer which is called, note that the currentValue argument contains the existing\n     *                 value or is undefined when no mapping exists for the key.\n     * @return The newly computed value\n     */\n    compute(key, computer) {\n        const currentValue = this.get(key);\n        const newValue = computer(key, currentValue);\n        if (newValue) {\n            this.set(key, newValue);\n        }\n        else {\n            this.delete(key);\n        }\n        return newValue;\n    }\n}\n\n/**\n * Internal log level (note: do NOT use LogLevel, or we get circular loading issues!)\n */\nvar InternalLogLevel;\n(function (InternalLogLevel) {\n    InternalLogLevel[InternalLogLevel[\"Trace\"] = 0] = \"Trace\";\n    InternalLogLevel[InternalLogLevel[\"Debug\"] = 1] = \"Debug\";\n    InternalLogLevel[InternalLogLevel[\"Info\"] = 2] = \"Info\";\n    InternalLogLevel[InternalLogLevel[\"Warn\"] = 3] = \"Warn\";\n    InternalLogLevel[InternalLogLevel[\"Error\"] = 4] = \"Error\";\n})(InternalLogLevel || (InternalLogLevel = {}));\n/**\n * Internal logger, this is NOT for end users. Instead this is used to enable logging for typescript-logging itself in case of problems.\n *\n * @param name Name of logger\n */\nfunction getInternalLogger(name) {\n    return provider.getLogger(name);\n}\n/**\n * Can be used to change the *internal* logging of the library.\n * Has no effect on end user logging.\n *\n * As such should normally not be used by end users.\n */\nconst INTERNAL_LOGGING_SETTINGS = {\n    /**\n     * Changes the log level for the internal logging (for all new and existing loggers)\n     * @param level New log level\n     */\n    setInternalLogLevel: (level) => provider.changeLogLevel(level),\n    /**\n     * Changes where messages are written to for all new and existing loggers),\n     * by default they are written to the console.\n     * @param fnOutput Function to write messages to\n     */\n    setOutput: (fnOutput) => provider.changeOutput(fnOutput),\n    /**\n     * Resets the log level and output back to defaults (level to error and writing to console)\n     * for all new and existing loggers.\n     */\n    reset: () => provider.reset(),\n};\nclass InternalLoggerImpl {\n    constructor(name, level, fnOutput) {\n        this._name = name;\n        this._level = level;\n        this._fnOutput = fnOutput;\n    }\n    trace(msg) {\n        this.log(InternalLogLevel.Trace, msg);\n    }\n    debug(msg) {\n        this.log(InternalLogLevel.Debug, msg);\n    }\n    error(msg, error) {\n        this.log(InternalLogLevel.Error, msg, error);\n    }\n    info(msg) {\n        this.log(InternalLogLevel.Info, msg);\n    }\n    warn(msg, error) {\n        this.log(InternalLogLevel.Warn, msg, error);\n    }\n    setLevel(level) {\n        this._level = level;\n    }\n    setOutput(fnOutput) {\n        this._fnOutput = fnOutput;\n    }\n    log(level, msg, error) {\n        if (this._level > level) {\n            return;\n        }\n        // tslint:disable-next-line:no-console\n        this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${msg()}${error ? \"\\n\" + error.stack : \"\"}`);\n    }\n}\nclass InternalProviderImpl {\n    constructor() {\n        this._loggers = new EnhancedMap();\n        this._logLevel = InternalLogLevel.Error;\n        this._fnOutput = InternalProviderImpl.logConsole;\n    }\n    getLogger(name) {\n        return this._loggers.computeIfAbsent(name, key => new InternalLoggerImpl(key, this._logLevel, this._fnOutput));\n    }\n    changeLogLevel(level) {\n        this._logLevel = level;\n        this._loggers.forEach(logger => logger.setLevel(level));\n    }\n    changeOutput(_fnOutput) {\n        this._fnOutput = _fnOutput;\n        this._loggers.forEach(logger => logger.setOutput(this._fnOutput));\n    }\n    reset() {\n        this.changeLogLevel(InternalLogLevel.Error);\n        this._fnOutput = InternalProviderImpl.logConsole;\n        this._loggers.forEach(logger => logger.setOutput(this._fnOutput));\n    }\n    static logConsole(msg) {\n        // tslint:disable-next-line:no-console\n        if (console && console.log) {\n            // tslint:disable-next-line:no-console\n            console.log(msg);\n        }\n    }\n}\nconst provider = new InternalProviderImpl();\n\nvar InternalLogger = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS,\n  get InternalLogLevel () { return InternalLogLevel; },\n  getInternalLogger: getInternalLogger\n});\n\n/**\n * Log level for a logger.\n */\nvar LogLevel;\n(function (LogLevel) {\n    // Do not change values/order. Logging a message relies on this.\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 3] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n    LogLevel[LogLevel[\"Fatal\"] = 5] = \"Fatal\";\n    LogLevel[LogLevel[\"Off\"] = 6] = \"Off\";\n})(LogLevel || (LogLevel = {}));\n/* tslint:disable:no-namespace */\n(function (LogLevel) {\n    /**\n     * Convert given value to LogLevel, if not matching returns undefined.\n     * @param val Value to convert\n     */\n    function toLogLevel(val) {\n        switch (val.toLowerCase()) {\n            case \"trace\":\n                return LogLevel.Trace;\n            case \"debug\":\n                return LogLevel.Debug;\n            case \"info\":\n                return LogLevel.Info;\n            case \"warn\":\n                return LogLevel.Warn;\n            case \"error\":\n                return LogLevel.Error;\n            case \"fatal\":\n                return LogLevel.Fatal;\n            case \"off\":\n                return LogLevel.Off;\n            default:\n                return undefined;\n        }\n    }\n    LogLevel.toLogLevel = toLogLevel;\n})(LogLevel || (LogLevel = {}));\n/* tslint:disable:enable-namespace */\n\n/**\n * Standard logger implementation that provides the basis for all loggers.\n */\nclass CoreLoggerImpl {\n    constructor(runtime) {\n        this._runtime = runtime;\n    }\n    get id() {\n        return this._runtime.id;\n    }\n    get logLevel() {\n        return this._runtime.level;\n    }\n    get runtimeSettings() {\n        /* Return it as new literal, we don't want people to play with our internal state */\n        return Object.assign({}, this._runtime);\n    }\n    set runtimeSettings(runtime) {\n        this._runtime = runtime;\n    }\n    trace(message, ...args) {\n        this.logMessage(LogLevel.Trace, message, args);\n    }\n    debug(message, ...args) {\n        this.logMessage(LogLevel.Debug, message, args);\n    }\n    info(message, ...args) {\n        this.logMessage(LogLevel.Info, message, args);\n    }\n    warn(message, ...args) {\n        this.logMessage(LogLevel.Warn, message, args);\n    }\n    error(message, ...args) {\n        this.logMessage(LogLevel.Error, message, args);\n    }\n    fatal(message, ...args) {\n        this.logMessage(LogLevel.Fatal, message, args);\n    }\n    logMessage(level, logMessageType, args) {\n        if (this._runtime.level > level) {\n            return;\n        }\n        const nowMillis = Date.now();\n        const message = typeof logMessageType === \"string\" ? logMessageType : logMessageType();\n        const errorAndArgs = CoreLoggerImpl.getErrorAndArgs(args);\n        /*\n         * Deal with raw message here.\n         */\n        switch (this._runtime.channel.type) {\n            case \"RawLogChannel\":\n                this._runtime.channel.write({\n                    message,\n                    exception: errorAndArgs.error,\n                    args: errorAndArgs.args,\n                    timeInMillis: nowMillis,\n                    level,\n                    logNames: this._runtime.name,\n                }, this._runtime.argumentFormatter);\n                return;\n            case \"LogChannel\":\n                this._runtime.channel.write(this.createLogMessage(message, level, errorAndArgs, nowMillis));\n                break;\n        }\n    }\n    formatArgValue(value) {\n        try {\n            return this._runtime.argumentFormatter(value);\n        }\n        catch (e) {\n            // We don't really care what failed, except that the convert function failed.\n            return `>>ARG CONVERT FAILED: '${value !== undefined ? value.toString() : \"undefined\"}'<<`;\n        }\n    }\n    createLogMessage(message, level, errorAndArgs, nowMillis) {\n        let errorResult;\n        const error = errorAndArgs.error;\n        const args = errorAndArgs.args;\n        if (error) {\n            errorResult = `${error.name}: ${error.message}`;\n            if (error.stack) {\n                errorResult += `@\\n${error.stack}`;\n            }\n        }\n        /*\n         * We need to add the date, and log names (in front of the now formatted message).\n         * Finally we also need to format any additional arguments and append after the message.\n         */\n        const dateFormatted = this._runtime.dateFormatter(nowMillis);\n        let levelAsStr = LogLevel[level].toUpperCase();\n        if (levelAsStr.length < 5) {\n            levelAsStr += \" \";\n        }\n        const names = typeof this._runtime.name === \"string\" ? this._runtime.name : this._runtime.name.join(\", \");\n        const argsFormatted = typeof args !== \"undefined\" && args.length > 0 ? (\" [\" + (args.map(arg => this.formatArgValue(arg))).join(\", \") + \"]\") : \"\";\n        const completedMessage = dateFormatted + \" \" + levelAsStr + \" [\" + names + \"] \" + message + argsFormatted;\n        return {\n            message: completedMessage,\n            error: errorResult,\n        };\n    }\n    static getErrorAndArgs(args) {\n        /*\n          The args are optional, but the first entry may be an Error or a function to an Error, or finally be a function to extra arguments.\n          The last is only true, if the length of args === 1, otherwise we expect args starting at pos 1 and further to be just that - args.\n         */\n        if (args.length === 0) {\n            return {};\n        }\n        let error;\n        let actualArgs;\n        const value0 = args[0];\n        /* If the first argument is an Error, we can stop straight away, the rest are additional arguments then if any */\n        if (value0 instanceof Error) {\n            error = value0;\n            actualArgs = args.length > 1 ? args.slice(1) : undefined;\n            return { error, args: actualArgs };\n        }\n        /* If the first argument is a function, it means either it will return the Error, or if the array length === 1 a function, returning the arguments */\n        if (typeof value0 === \"function\") {\n            const errorOrArgs = value0();\n            if (errorOrArgs instanceof Error) {\n                error = errorOrArgs;\n                actualArgs = args.length > 1 ? args.slice(1) : undefined;\n                return { error, args: actualArgs };\n            }\n            if (args.length === 1) {\n                /* The first argument was a function, we assume it returned the extra argument(s) */\n                if (Array.isArray(errorOrArgs)) {\n                    return { args: errorOrArgs.length > 0 ? errorOrArgs : undefined };\n                }\n                else {\n                    /* No idea what was returned we just assume a single value */\n                    return { args: errorOrArgs };\n                }\n            }\n            else {\n                /*\n                  This is a weird situation but there's no way to avoid it, the first argument was a function but did not return an Error and the args are > 1,\n                  so just add the args returned, as well as any remaining.\n                */\n                if (Array.isArray(errorOrArgs)) {\n                    return { args: [...errorOrArgs, ...args.slice(1)] };\n                }\n                return { args: [errorOrArgs, ...args.slice(1)] };\n            }\n        }\n        /* All args are ordinary arguments, or at least the first arg was not an Error or a Function, so we add all as args */\n        return { args };\n    }\n}\n\n/**\n * Pad given value with given fillChar from the beginning (default is an empty space)\n * @param value Value to pad\n * @param length The length the string must be\n * @param fillChar The padding char (1 char length allowed only)\n * @return Padded string or the same string if it is already of given length (or larger).\n */\nfunction padStart(value, length, fillChar = \" \") {\n    return padInternal(value, length, \"start\", fillChar);\n}\n/**\n * Pad given value with given fillChar from the end (default is an empty space)\n * @param value Value to pad\n * @param length The length the string must be\n * @param fillChar The padding char (1 char length allowed only)\n * @return Padded string or the same string if it is already of given length (or larger).\n */\nfunction padEnd(value, length, fillChar = \" \") {\n    return padInternal(value, length, \"end\", fillChar);\n}\n/**\n * Returns the max length of a string value in given array\n * @param arr Array to check\n * @return Max length, 0 if array is empty\n */\nfunction maxLengthStringValueInArray(arr) {\n    return arr\n        .map(v => v.length)\n        .reduce((previous, current) => {\n        if (current > previous) {\n            return current;\n        }\n        return previous;\n    }, 0);\n}\nfunction padInternal(value, length, padType, fillChar = \" \") {\n    if (length <= value.length) {\n        return value;\n    }\n    if (fillChar.length > 1) {\n        throw new Error(`Fill char must be one char exactly, it is: ${fillChar.length}`);\n    }\n    const charsNeeded = length - value.length;\n    let padding = \"\";\n    for (let i = 0; i < charsNeeded; i++) {\n        padding += fillChar;\n    }\n    if (padType === \"start\") {\n        return padding + value;\n    }\n    return value + padding;\n}\n\n/**\n * Default argument formatter function, used by the library, see {@link ArgumentFormatterType}.\n * Can be used by an end user as well if needed.\n * @param arg The argument to format\n * @returns argument stringified to string (JSON.stringify), if arg is undefined returns \"undefined\" (without quotes).\n */\nfunction formatArgument(arg) {\n    if (arg === undefined) {\n        return \"undefined\";\n    }\n    return JSON.stringify(arg);\n}\n/**\n * Default date formatter function, used by the library, see {@link DateFormatterType}.\n * Can be used by an end user as well if needed.\n * @param millisSinceEpoch Milliseconds since epoch\n * @returns The date in format: yyyy-MM-dd HH:mm:ss,SSS (example: 2021-02-26 09:06:28,123)\n */\nfunction formatDate(millisSinceEpoch) {\n    const date = new Date(millisSinceEpoch);\n    const year = date.getFullYear();\n    const month = padStart((date.getMonth() + 1).toString(), 2, \"0\");\n    const day = padStart(date.getDate().toString(), 2, \"0\");\n    const hours = padStart(date.getHours().toString(), 2, \"0\");\n    const minutes = padStart(date.getMinutes().toString(), 2, \"0\");\n    const seconds = padStart(date.getSeconds().toString(), 2, \"0\");\n    const millis = padStart(date.getMilliseconds().toString(), 3, \"0\");\n    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds},${millis}`;\n}\n\n/* tslint:disable:no-console */\n/**\n * Default standard LogChannel which logs to console.\n */\nclass ConsoleLogChannel {\n    constructor() {\n        this.type = \"LogChannel\";\n    }\n    write(msg) {\n        if (console && console.log) {\n            console.log(msg.message + (msg.error ? `\\n${msg.error}` : \"\"));\n        }\n    }\n}\n\n/* tslint:disable:no-namespace */\n/**\n * Provides access to various default channels provided by typescript logging.\n */\nvar DefaultChannels;\n(function (DefaultChannels) {\n    /**\n     * Create a new standard LogChannel that logs to the console.\n     */\n    function createConsoleChannel() {\n        return new ConsoleLogChannel();\n    }\n    DefaultChannels.createConsoleChannel = createConsoleChannel;\n})(DefaultChannels || (DefaultChannels = {}));\n\n/**\n * Implementation for {@link LogProvider}\n */\nclass LogProviderImpl {\n    constructor(name, settings) {\n        this._log = getInternalLogger(\"core.impl.LogProviderImpl\");\n        this._name = name;\n        this._settings = settings;\n        this._loggers = new EnhancedMap();\n        this._idToKeyMap = new EnhancedMap();\n        this._globalRuntimeSettings = { level: settings.level, channel: settings.channel };\n        this._nextLoggerId = 1;\n        this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);\n    }\n    get runtimeSettings() {\n        return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });\n    }\n    getLogger(name) {\n        return this.getOrCreateLogger(name);\n    }\n    updateLoggerRuntime(log, settings) {\n        this._log.debug(() => `Updating logger ${log.id} runtime settings using: '${JSON.stringify(settings)}'`);\n        const key = this._idToKeyMap.get(log.id);\n        if (key === undefined) {\n            this._log.warn(() => `Cannot update logger with id: ${log.id}, it was not found.`);\n            return false;\n        }\n        this._loggers.computeIfPresent(key, (currentKey, currentValue) => {\n            currentValue.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(currentValue.runtimeSettings, settings);\n            return currentValue;\n        });\n        return true;\n    }\n    updateRuntimeSettings(settings) {\n        this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(settings)}'`);\n        this._globalRuntimeSettings = {\n            /*\n             * Undefined check is necessary, as level is a number (and LogLevel.Trace = 0), a ternary check otherwise results in the annoying \"truthy/falsy\"\n             * behavior of javascript where 0 is seen as false.\n             */\n            level: settings.level !== undefined ? settings.level : this._globalRuntimeSettings.level,\n            channel: settings.channel !== undefined ? settings.channel : this._globalRuntimeSettings.channel,\n        };\n        this._loggers.forEach(logger => logger.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(logger.runtimeSettings, settings));\n    }\n    /**\n     * Removes all state and loggers, it reverts back to as it was after initial construction.\n     */\n    clear() {\n        this._loggers.clear();\n        this._idToKeyMap.clear();\n        this._globalRuntimeSettings = Object.assign({}, this._settings);\n        this._nextLoggerId = 1;\n    }\n    getOrCreateLogger(name) {\n        const key = LogProviderImpl.createKey(name);\n        const logger = this._loggers.computeIfAbsent(key, () => {\n            const runtime = {\n                level: this._globalRuntimeSettings.level,\n                channel: this._globalRuntimeSettings.channel,\n                id: this.nextLoggerId(),\n                name,\n                argumentFormatter: this._settings.argumentFormatter,\n                dateFormatter: this._settings.dateFormatter,\n            };\n            return new CoreLoggerImpl(runtime);\n        });\n        this._idToKeyMap.computeIfAbsent(logger.id, () => key);\n        return logger;\n    }\n    nextLoggerId() {\n        const result = this._name + \"_\" + this._nextLoggerId;\n        this._nextLoggerId++;\n        return result;\n    }\n    static mergeRuntimeSettingsIntoLogRuntime(currentSettings, settings) {\n        return Object.assign(Object.assign({}, currentSettings), { \n            /*\n             * Undefined check is necessary, as level is a number (and LogLevel.Trace = 0), a ternary check otherwise results in the annoying \"truthy/falsy\"\n             * behavior of javascript where 0 is seen as false.\n             */\n            level: settings.level !== undefined ? settings.level : currentSettings.level, channel: settings.channel !== undefined ? settings.channel : currentSettings.channel });\n    }\n    static createKey(name) {\n        if (typeof name === \"string\") {\n            return name;\n        }\n        return name.join(\",\");\n    }\n}\n\n/**\n * Create a new LogProvider, this is for flavor usage only. End users should not\n * use this and instead use whatever the flavor offers to build some config and\n * get loggers from there.\n */\nfunction createLogProvider(name, settings) {\n    return new LogProviderImpl(name, settings);\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  EnhancedMap: EnhancedMap,\n  maxLengthStringValueInArray: maxLengthStringValueInArray,\n  padEnd: padEnd,\n  padStart: padStart\n});\n\nfunction log4TSGroupConfigDebug(config) {\n    return `Log4TSGroupConfig=level: ${LogLevel[config.level].toString()}, expression: ${config.expression.toString()}, (omitted functions/channel)`;\n}\nfunction log4TSConfigDebug(config) {\n    const groupLog = config.groups.map(g => log4TSGroupConfigDebug(g)).join(\", \");\n    return `Log4TSGroupConfig=level: ${LogLevel[config.level].toString()}, groups: ${groupLog}, (omitted functions/channel)`;\n}\n\n/**\n * Implementation class for Log4TSProvider.\n */\nclass Log4TSProviderImpl {\n    constructor(name, defaultConfig, groupConfigs) {\n        this._log = InternalLogger.getInternalLogger(\"log4ts.impl.Log4TSProviderImpl\");\n        this._name = name;\n        /* The default config, used as fallback if a logger does not match any group */\n        this._defaultConfig = [Object.assign(Object.assign({}, defaultConfig), { identifier: defaultConfig.identifier }), createLogProvider(\"log4ts_\" + name + \"_\" + defaultConfig.identifier, defaultConfig)];\n        /* Create various providers for the different groups so each will have the correct config */\n        this._logProviders = new Map(groupConfigs.map(config => {\n            const updatedConfig = Object.assign({}, config);\n            const provider = createLogProvider(\"log4ts_\" + name + \"_\" + config.identifier, config);\n            return [config.identifier, { groupConfig: updatedConfig, provider }];\n        }));\n        this._log.trace(() => {\n            const groupProvLog = [...this._logProviders.values()].map(e => log4TSGroupConfigDebug(e.groupConfig)).join(\", \");\n            return `Creating Log4TSProviderImpl '${this._name}', defaultConfig: ${log4TSGroupConfigDebug(this._defaultConfig[0])}, groupConfigs: ${groupProvLog}`;\n        });\n    }\n    get name() {\n        return this._name;\n    }\n    get config() {\n        /* We create the settings to return anew, to prevent people change the content in any way */\n        return Object.assign({}, this._defaultConfig[0]);\n    }\n    get groupConfigs() {\n        /* We create the settings to return anew, to prevent people change the content in any way */\n        return [...this._logProviders.values()].map(v => (Object.assign({}, v.groupConfig)));\n    }\n    getLogger(name) {\n        /* Walk them in insertion order, that is the order we must match for */\n        for (const value of this._logProviders.values()) {\n            if (value.groupConfig.expression.test(name)) {\n                return value.provider.getLogger(name);\n            }\n        }\n        /* Fallback to the default we don't care if it matches in this case */\n        return this._defaultConfig[1].getLogger(name);\n    }\n    updateRuntimeSettingsGroup(identifier, config) {\n        const value = this._logProviders.get(identifier);\n        if (value === undefined) {\n            throw new Error(`Cannot update group with identifier '${identifier}', it does not exist.`);\n        }\n        this._log.debug(() => `Will update ${log4TSGroupConfigDebug(value.groupConfig)}, associated LogProvider '${value.provider}' - applying runtime change: ${JSON.stringify(config)}.`);\n        Log4TSProviderImpl.updateLog4TGroupConfig(value.groupConfig, value.provider, config);\n    }\n    updateRuntimeSettings(settings) {\n        this._log.debug(() => `Will update settings for all groups and existing loggers - will apply runtime change: ${JSON.stringify(settings)}.`);\n        this._logProviders.forEach(value => {\n            const groupConfig = value.groupConfig;\n            const provider = value.provider;\n            this._log.debug(() => `Will update ${log4TSGroupConfigDebug(groupConfig)}, associated LogProvider '${provider}' - applying runtime change: ${JSON.stringify(settings)}.`);\n            Log4TSProviderImpl.updateLog4TGroupConfig(groupConfig, provider, settings);\n        });\n    }\n    static updateLog4TGroupConfig(cfg, provider, runtimeSettings) {\n        if (runtimeSettings.level) {\n            cfg.level = runtimeSettings.level;\n        }\n        if (runtimeSettings.channel) {\n            cfg.channel = runtimeSettings.channel;\n        }\n        provider.updateRuntimeSettings(runtimeSettings);\n    }\n}\n\n/**\n * Implementation for Log4TSControlProvider.\n */\nclass Log4TSControlProviderImpl {\n    constructor(provider, messageChannel) {\n        this._provider = provider;\n        this._messageChannel = messageChannel;\n        // Identifier is guaranteed to be set internally.\n        this._originalLogLevels = Log4TSControlProviderImpl.loadCurrentGroupLogLevels(provider);\n    }\n    get name() {\n        return this._provider.name;\n    }\n    showSettings() {\n        let result = `Available group configs (Log4TSProvider '${this._provider.name}'):\\n`;\n        /*\n         * Make the identifier always set, similar on how to update a group.\n         */\n        const groupConfigs = this._provider.groupConfigs.map(cfg => ({\n            level: LogLevel[cfg.level],\n            channelDescription: cfg.channel.toString ? cfg.channel.toString() : JSON.stringify(cfg.channel),\n            identifier: cfg.identifier,\n        }));\n        const maxWidthIndex = groupConfigs.length.toString().length;\n        const maxWidthIdentifier = index.maxLengthStringValueInArray(groupConfigs.map(cfg => cfg.identifier));\n        const maxWidthLevel = 5;\n        /*\n          We create this kind of output:\n    \n          Available group configs (Log4TSProvider 'test'):\n            [0, /model.+/:             level=Error]\n            [1, /advanced.+/:          level=Warn ]\n            [2, my awesome identifier: level=Error]\n            [3, /blaat.blaat.+/:       level=Error]\n         */\n        const providerLines = groupConfigs\n            .map((cfg, index$1) => `  [${index.padStart(index$1.toString(), maxWidthIndex)}, ${index.padEnd(cfg.identifier, maxWidthIdentifier)} (level=${index.padEnd(cfg.level, maxWidthLevel)})]`)\n            .join(\"\\n\");\n        result += providerLines + \"\\n\";\n        this._messageChannel(result);\n    }\n    update(level, groupId) {\n        const newLevel = LogLevel.toLogLevel(level);\n        if (newLevel === undefined) {\n            throw new Error(`Cannot update log provider, log level '${level}' is invalid.`);\n        }\n        const settings = {\n            level: newLevel,\n        };\n        /*\n         * Update all groups.\n         */\n        if (groupId === undefined) {\n            this._provider.updateRuntimeSettings(settings);\n            this._messageChannel(\"Updated all group configs successfully.\");\n            return;\n        }\n        /*\n         * Find the group by index and update it using its identifier.\n         */\n        if (typeof groupId === \"number\") {\n            const groups = this._provider.groupConfigs;\n            if (groupId < 0 || groupId >= groups.length) {\n                throw new Error(`Group config with index '${groupId}' does not exist (outside of range).`);\n            }\n            const expectedGroup = groups[groupId];\n            this._provider.updateRuntimeSettingsGroup(expectedGroup.identifier, settings);\n            this._messageChannel(`Updated group config with index '${groupId}' successfully.`);\n            return;\n        }\n        /* Update the group by its identifier directly */\n        this._provider.updateRuntimeSettingsGroup(groupId, settings);\n        this._messageChannel(`Updated group config with id '${groupId}' successfully.`);\n    }\n    reset() {\n        this._originalLogLevels.forEach((value, key) => {\n            this._provider.updateRuntimeSettingsGroup(key, { level: value });\n        });\n        this._messageChannel(\"Successfully reset log levels back to original state (from when this Log4TSControlProvider was created).\");\n    }\n    save() {\n        if (!localStorage) {\n            this._messageChannel(\"Cannot save state, localStorage is not available.\");\n            return;\n        }\n        const data = {\n            name: this._provider.name,\n            groups: this._provider.groupConfigs.map(cfg => ({ identifier: cfg.identifier, level: LogLevel[cfg.level] })),\n        };\n        localStorage.setItem(this.createKey(), JSON.stringify(data));\n        this._messageChannel(`Successfully saved state for Log4TSControlProvider '${this._provider.name}'.`);\n    }\n    restore(logRestoreFailures) {\n        const finalLogRestoreFailures = logRestoreFailures !== undefined ? logRestoreFailures : true;\n        if (!localStorage) {\n            if (finalLogRestoreFailures) {\n                this._messageChannel(`Will not attempt to restore state for Log4TSControlProvider '${this._provider.name}', localStorage is not available.`);\n            }\n            return;\n        }\n        const key = this.createKey();\n        const value = localStorage.getItem(key);\n        if (value === null) {\n            if (finalLogRestoreFailures) {\n                this._messageChannel(`Cannot restore state for Log4TSControlProvider '${this._provider.name}', no data available.`);\n            }\n            return;\n        }\n        try {\n            const savedData = JSON.parse(value);\n            if (this._provider.name !== savedData.name) {\n                if (finalLogRestoreFailures) {\n                    this._messageChannel(`Cannot restore state for Log4TSControlProvider '${this._provider.name}', data is not for provider - found name '${savedData.name}'.`);\n                }\n                return;\n            }\n            this.restoreGroups(savedData, finalLogRestoreFailures);\n            this._originalLogLevels = Log4TSControlProviderImpl.loadCurrentGroupLogLevels(this._provider);\n        }\n        catch (e) {\n            localStorage.removeItem(key);\n            this._messageChannel(`Cannot restore state for Log4TSControlProvider '${this._provider.name}', data is not valid. Invalid data removed from localStorage.`);\n        }\n    }\n    help() {\n        const msg = `You can use the following commands (Log4TSProvider ${this._provider.name}):\\n` +\n            \"  showSettings()\\n\" +\n            \"    Shows the current configuration settings.\\n\" +\n            \"  update(logLevel: Log4TSControlProviderLogLevel, groupId?: number | string)\\n\" +\n            \"    Change the log level for one or all config groups.\\n\" +\n            \"      @param level   The log level to set - must be one of 'trace', 'debug', 'info', 'warn', 'error' or 'fatal'\\n\" +\n            \"      @param groupId Optional group config to update by either index or identifier, when omitted updates all groups.\\n\" +\n            \"                     Use showSettings() to find details about index and/or identifier.\\n\" +\n            \"  reset()\\n\" +\n            \"    Resets the log levels of the config groups back to when this control provider was created.\\n\" +\n            \"  save()\\n\" +\n            \"    Saves the current log levels for all config groups of this provider. Use restore() to load last saved state.\\n\" +\n            \"  restore()\\n\" +\n            \"    Restore stored saved state, if any. Log levels will be set according to saved state.\\n\" +\n            \"  help()\\n\" +\n            \"    Shows this help.\\n\";\n        this._messageChannel(msg);\n    }\n    restoreGroups(saveData, logCannotRestore) {\n        saveData.groups.forEach(group => {\n            try {\n                const newLevel = LogLevel.toLogLevel(group.level);\n                if (newLevel !== undefined) {\n                    this._provider.updateRuntimeSettingsGroup(group.identifier, { level: newLevel });\n                    this._messageChannel(`Log4TSControlProvider '${this._provider.name}' - restored log level of group '${group.identifier}' to '${LogLevel[newLevel]}'.`);\n                }\n                else {\n                    if (logCannotRestore) {\n                        this._messageChannel(`Log4TSControlProvider '${this._provider.name}' - failed to restore log level of group '${group.identifier}', invalid log level was specified.`);\n                    }\n                }\n            }\n            catch (e) {\n                if (logCannotRestore) {\n                    this._messageChannel(`Log4TSControlProvider '${this._provider.name}' - failed to restore log level of group '${group.identifier}'.`);\n                }\n            }\n        });\n    }\n    createKey() {\n        return `Log4TSProvider-${this._provider.name}`;\n    }\n    static loadCurrentGroupLogLevels(provider) {\n        return new Map(provider.groupConfigs.map(cfg => [cfg.identifier, cfg.level]));\n    }\n}\n\n/**\n * Provider for the Log4TS flavor, each provider is a unique instance that can be used to\n * get loggers from.\n */\nclass Log4TSProviderService {\n    constructor() {\n        this._log = InternalLogger.getInternalLogger(\"log4ts.impl.Log4TSProviderService\");\n        this._providers = new index.EnhancedMap();\n    }\n    createLogProvider(name, config) {\n        const result = this._providers.compute(name, (key, currentValue) => {\n            if (currentValue) {\n                throw new Error(`Log4TSProvider with name '${name}' already exists, cannot create another.`);\n            }\n            const mainConfig = mergeLog4TSConfigs(createDefaultLog4TSConfig(), config);\n            validateLog4TSConfig(mainConfig);\n            this._log.debug(() => `Creating new Log4TSProvider with name '${name}', using main config settings '${log4TSConfigDebug(mainConfig)}'.`);\n            const defaultExpression = new RegExp(\".+\");\n            const defaultGroupConfig = {\n                channel: mainConfig.channel,\n                level: mainConfig.level,\n                expression: defaultExpression,\n                dateFormatter: mainConfig.dateFormatter,\n                argumentFormatter: mainConfig.argumentFormatter,\n                identifier: defaultExpression.toString(),\n            };\n            return new Log4TSProviderImpl(key, defaultGroupConfig, mainConfig.groups);\n        });\n        // Cannot be undefined we do not allow it.\n        return result;\n    }\n    /**\n     * Clears all providers and configuration, the service reverts back to initial state.\n     */\n    clear() {\n        this._providers.clear();\n    }\n    getLog4TSControl(fnValue) {\n        const fnMessageChannel = fnValue ? fnValue : (value) => {\n            // tslint:disable-next-line:no-console\n            if (console && console.log) {\n                // tslint:disable-next-line:no-console\n                console.log(value);\n            }\n            else {\n                throw new Error(\"Cannot use console (it is not present), please specify a custom function to write to.\");\n            }\n        };\n        return {\n            help: () => fnMessageChannel(Log4TSProviderService.help()),\n            showSettings: () => fnMessageChannel(this.showSettings()),\n            getProvider: (id) => this.getLog4TSControlProviderByIdOrName(id, fnMessageChannel),\n        };\n    }\n    showSettings() {\n        let result = \"Available Log4TSProviders:\\n\";\n        const maxWidthIndex = this._providers.size.toString().length;\n        const maxWidthName = index.maxLengthStringValueInArray([...this._providers.keys()]);\n        const lines = [...this._providers.entries()].map((entry, index$1) => {\n            const name = entry[0];\n            /* [idx, name] */\n            return `  [${index.padStart(index$1.toString(), maxWidthIndex)}, ${index.padEnd(name, maxWidthName)}]`;\n        });\n        result += lines.join(\"\\n\") + (lines.length > 0 ? \"\\n\" : \"\");\n        return result;\n    }\n    getLog4TSControlProviderByIdOrName(id, messageChannel) {\n        if (typeof id === \"string\") {\n            const provider = this._providers.get(id);\n            if (provider === undefined) {\n                throw new Error(`Provider with name '${id}' does not exist.`);\n            }\n            return new Log4TSControlProviderImpl(provider, messageChannel);\n        }\n        const providers = [...this._providers.values()];\n        if (id < 0 || id >= providers.length) {\n            throw new Error(`Provider with index '${id}' does not exist (outside of range).`);\n        }\n        return new Log4TSControlProviderImpl(providers[id], messageChannel);\n    }\n    static help() {\n        return \"You can use the following commands:\\n\" +\n            \"  showSettings()\\n\" +\n            \"    Shows the current configuration settings.\\n\" +\n            \"  getProvider: (id: number | string): Log4TSControlProvider\\n\" +\n            \"    Get access to a Log4TSControlProvider to change log levels.\\n\" +\n            \"      @param id The id (use showSettings to see) or name of the provider\\n\" +\n            \"  help()\\n\" +\n            \"    Shows this help.\\n\";\n    }\n}\n/**\n * Singleton instance to the service, for internal usage only. Must NOT be exported to end user.\n */\nconst LOG4TS_PROVIDER_SERVICE = new Log4TSProviderService();\nconst LOG4TS_LOG_CONTROL = fnValue => LOG4TS_PROVIDER_SERVICE.getLog4TSControl(fnValue);\nfunction createDefaultLog4TSConfig() {\n    return {\n        argumentFormatter: formatArgument,\n        channel: DefaultChannels.createConsoleChannel(),\n        dateFormatter: formatDate,\n        groups: [],\n        level: LogLevel.Error,\n    };\n}\nfunction mergeLog4TSConfigs(lhs, rhs) {\n    const value = {\n        argumentFormatter: rhs.argumentFormatter ? rhs.argumentFormatter : lhs.argumentFormatter,\n        channel: rhs.channel ? rhs.channel : lhs.channel,\n        dateFormatter: rhs.dateFormatter ? rhs.dateFormatter : lhs.dateFormatter,\n        groups: [],\n        level: rhs.level !== undefined ? rhs.level : lhs.level,\n    };\n    /*\n     * Groups must take over the defaults from the main config when they don't specify config themselves.\n     */\n    value.groups = rhs.groups.map(groupConfig => mergeLog4TSGroupConfigs(value, groupConfig));\n    return value;\n}\nfunction mergeLog4TSGroupConfigs(lhs, rhs) {\n    return {\n        argumentFormatter: rhs.argumentFormatter ? rhs.argumentFormatter : lhs.argumentFormatter,\n        channel: lhs.channel,\n        dateFormatter: rhs.dateFormatter ? rhs.dateFormatter : lhs.dateFormatter,\n        expression: rhs.expression,\n        level: rhs.level !== undefined ? rhs.level : lhs.level,\n        identifier: rhs.identifier ? rhs.identifier : rhs.expression.toString(),\n    };\n}\nfunction validateLog4TSConfig(config) {\n    if (config.groups.length === 0) {\n        throw new Error(\"Invalid configuration, 'groups' on configuration is empty, at least 1 group config must be specified.\");\n    }\n}\n\n// tslint:disable-next-line:no-namespace\nvar Log4TSProvider;\n(function (Log4TSProvider) {\n    /**\n     * Creates a new log provider with given name and configuration. If a provider\n     * with such name already exists, an Error will be thrown.\n     * @param name Name for provider, must be unique\n     * @param config The config for the provider\n     */\n    function createProvider(name, config) {\n        return LOG4TS_PROVIDER_SERVICE.createLogProvider(name, config);\n    }\n    Log4TSProvider.createProvider = createProvider;\n    /**\n     * Resets and clears *all* created Log4TSProviders, every logger that was retrieved previously\n     * through any of them will be invalid afterwards.\n     *\n     * This call essentially reverts the created Log4TSProviders back to their initial state. This should normally not be used\n     * unless absolutely necessary.\n     */\n    function clear() {\n        LOG4TS_PROVIDER_SERVICE.clear();\n    }\n    Log4TSProvider.clear = clear;\n})(Log4TSProvider || (Log4TSProvider = {}));\n\nexport { LOG4TS_LOG_CONTROL, Log4TSProvider };\n//# sourceMappingURL=typescript-logging-log4ts.esm.js.map\n","/*--- config/LogConfig.ts ---*/\nimport { LogLevel } from \"typescript-logging\";\nimport { Log4TSProvider } from \"typescript-logging-log4ts-style\";\nexport const log4TSProvider = Log4TSProvider.createProvider(\"AwesomeLog4TSProvider\", {\n    level: LogLevel.Debug,\n    groups: [{\n            expression: new RegExp(\".+\"),\n        }]\n});\n","import { log4TSProvider } from \"../config/ConfigLog4j\";\nconst log = log4TSProvider.getLogger(\"content-script-openai.ts\");\nvar chatEventStartDate = null;\n// Wait for any DOM element to be changed\nconst observer = new MutationObserver((mutationsList, observer) => {\n    for (const mutation of mutationsList) {\n        if (mutation.type === 'childList') {\n            mutation.addedNodes.forEach((e) => {\n                // handle the case in which the window is updated with the new generated text\n                log.debug('Received new node: ' + e.className);\n                if (typeof e.className === \"string\" && e.className === \"fixed right-4 top-8 my-2 flex max-h-[90vh] flex-col-reverse space-y-2 space-y-reverse overflow-y-auto px-2 py-4\") {\n                    const allNodes = document.querySelectorAll('div.markdown.prose');\n                    const model = document.querySelectorAll('span.text-token-text-secondary');\n                    const outputText = allNodes[allNodes.length - 1].textContent;\n                    log.debug('ChatGPT inference done!');\n                    const selectedModelString = (\"\" === model[0].textContent ? \"gpt-4\" : \"gpt-\" + model[0].textContent);\n                    log.debug('ChatGPT model selected! : ' + selectedModelString);\n                    log.debug('ChatGPT output finsihed! : ' + outputText);\n                    log.debug('Window URL! : ' + document.location.href);\n                    var raw = {\n                        url: document.location.href, // \"https://chatgpt.com/\",\n                        body: \"{\\\"model\\\":\\\"\" + selectedModelString + \"\\\"}\",\n                        generated_text: outputText,\n                        starttime: chatEventStartDate,\n                        latency: Date.now() - chatEventStartDate,\n                    };\n                    window.postMessage({ type: 'NEW_CHATEVENTRAW', chateventraw: raw }, '*');\n                    chatEventStartDate = null;\n                }\n                // handle click on the submit button\n                else if (typeof e.className === \"string\" && e.className.includes(\"w-full text-token-text-primary focus-visible:outline-2 focus-visible:outline-offset-[-4px]\")) {\n                    log.debug('ChatGPT submit button clicked - inference starting!');\n                    if (chatEventStartDate == null) {\n                        chatEventStartDate = Date.now();\n                    }\n                }\n            });\n        }\n    }\n});\nobserver.observe(document.body, { childList: true, subtree: true });\nlog.debug(\"content-script-openai.js: Content script loaded!\");\n"],"names":["EnhancedMap","Map","computeIfAbsent","key","computer","this","has","get","newValue","set","computeIfPresent","currentValue","undefined","delete","compute","InternalLogLevel","LogLevel","DefaultChannels","InternalLoggerImpl","constructor","name","level","fnOutput","_name","_level","_fnOutput","trace","msg","log","Trace","debug","Debug","error","Error","info","Info","warn","Warn","setLevel","setOutput","toString","stack","InternalProviderImpl","_loggers","_logLevel","logConsole","getLogger","changeLogLevel","forEach","logger","changeOutput","reset","console","toLogLevel","val","toLowerCase","Fatal","Off","ConsoleLogChannel","type","write","message","createConsoleChannel","setInternalLogLevel","Object","freeze","__proto__","INTERNAL_LOGGING_SETTINGS","getInternalLogger","runtime","_runtime","id","logLevel","runtimeSettings","assign","args","logMessage","fatal","logMessageType","nowMillis","Date","now","errorAndArgs","getErrorAndArgs","channel","exception","timeInMillis","logNames","argumentFormatter","createLogMessage","formatArgValue","value","e","errorResult","dateFormatted","dateFormatter","levelAsStr","toUpperCase","length","join","map","arg","actualArgs","value0","slice","errorOrArgs","Array","isArray","fillChar","padType","charsNeeded","padding","i","JSON","stringify","millisSinceEpoch","date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","settings","_log","_settings","_idToKeyMap","_globalRuntimeSettings","_nextLoggerId","getOrCreateLogger","updateLoggerRuntime","currentKey","mergeRuntimeSettingsIntoLogRuntime","updateRuntimeSettings","clear","createKey","nextLoggerId","result","currentSettings","maxLengthStringValueInArray","arr","v","reduce","previous","current","padEnd","padStart","log4TSGroupConfigDebug","config","expression","Log4TSProviderImpl","defaultConfig","groupConfigs","_defaultConfig","identifier","_logProviders","updatedConfig","provider","groupConfig","groupProvLog","values","test","updateRuntimeSettingsGroup","updateLog4TGroupConfig","cfg","Log4TSControlProviderImpl","messageChannel","_provider","_messageChannel","_originalLogLevels","loadCurrentGroupLogLevels","showSettings","channelDescription","maxWidthIndex","maxWidthIdentifier","index$1","update","groupId","newLevel","groups","expectedGroup","save","localStorage","data","setItem","restore","logRestoreFailures","finalLogRestoreFailures","getItem","savedData","parse","restoreGroups","removeItem","help","saveData","logCannotRestore","group","Log4TSProviderService","_providers","createLogProvider","mainConfig","lhs","rhs","mergeLog4TSGroupConfigs","mergeLog4TSConfigs","validateLog4TSConfig","groupLog","g","log4TSConfigDebug","defaultExpression","RegExp","defaultGroupConfig","getLog4TSControl","fnValue","fnMessageChannel","getProvider","getLog4TSControlProviderByIdOrName","size","maxWidthName","keys","lines","entries","entry","providers","LOG4TS_PROVIDER_SERVICE","Log4TSProvider","createProvider","chatEventStartDate","MutationObserver","mutationsList","observer","mutation","addedNodes","className","allNodes","document","querySelectorAll","model","outputText","textContent","selectedModelString","location","href","raw","url","body","generated_text","starttime","latency","window","postMessage","chateventraw","includes","observe","childList","subtree"],"sourceRoot":""}